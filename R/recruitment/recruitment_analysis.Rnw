%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sweave script for wgeel recruitment analysis
% Author Cedric Briand / Estibaliz Diaz
% you can run this script with command sweave() or appropriate tools
% such as Eclipse or Rstudio
% this script is intended to run with sweave not knitr
% It produces a nice pdf which has to be turned into a less nice word document
% The problem is that the encoding of my files is Cp1252
% The only way out is a full shift to utf8, in init pass locale for R to Sys.setlocale("LC_ALL", "English_United States.932")
% In the preamble replace \usepackage[latin1]{inputenc} by \usepackage[utf8]{inputenc}
% Note the following does not work :
% iconv -f CP1252 -t UTF-8 recruitment_analysis.tex > recruitment_analysis_utf8.tex
% finally the command to run is : 
% cd C:\Users\cedric.briand\Documents\GitHub\WGEEL\R\recruitment
% pandoc -s -o recruitment.docx --from=latex --to=docx  recruitment_analysis.tex
% All this for producing a ugly word report :-( 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<init, eval=TRUE,echo=FALSE,results=hide>>=
Sys.setlocale("LC_ALL", "English_United States.932")
# Password are stored in R/etc/Rprofile.site
# For the moment the database is stored locally
CY<-2019 # current year ==> dont forget to update the graphics path below
# ----------------------------------
# wgeel2016 discussed that the correct way of 
# calculating average of predictions was to use geomean
# the option below can be changed from geomean to mean to change calculations
# it will change the average in model of glass eel graph and prediction
#----------------------------------------------------------
opt_calculation="geomean" # "geomean" or "mean"
opt_std="all" #"1979-1994" or "2000-2009" or "all"
options(width=90) # this sets the width of the output
#--------------------------------
# packages used by this script
#--------------------------------
#if(!require(RODBC)) install.packages("RODBC") ; require(RODBC)
if(!require(mgcv)) install.packages("mgcv") ; require(mgcv)
if(!require(car)) install.packages("car") ; require(car)
if(!require(ggplot2)) install.packages("ggplot2") ; require(ggplot2)
if(!require(reshape)) install.packages("reshape") ; require(reshape)
if(!require(reshape2)) install.packages("reshape2") ; require(reshape2)
if(!require(stacomirtools)) install.packages("stacomirtools") ; require(stacomirtools) # for ODBC connections
if(!require(stringr)) install.packages("stringr") ; require(stringr)
if(!require(Hmisc)) install.packages("Hmisc") ; require(Hmisc)
if(!require(xtable)) install.packages("xtable") ; require(xtable)
if(!require(grid)) install.packages("grid") ; require(grid)
if(!require(sqldf)) install.packages("sqldf") ; require(sqldf)
if(!require(RPostgreSQL)) install.packages("RPostgreSQL") ; require(RPostgreSQL)
if(!require(RColorBrewer)) install.packages("RColorBrewer") ; require(RColorBrewer)
if(!require(stacomiR)) install.packages("stacomiR") ; require(stacomiR)
if(!require(dplyr)) install.packages("dplyr") ; require(dplyr)
if(!require(sp)) install.packages("sp") ; require(sp)
if(!require(maptools)) install.packages("maptools") ; require(maptools)
if(!require(maps)) install.packages("maps") ; require(maps)
if(!require(boot)) install.packages("boot") ; require(boot)
if(!require(MASS)) install.packages("MASS") ; require(MASS)
if(!require(lme4)) install.packages("lme4") ; require(lme4)
if(!require(multcomp)) install.packages("multcomp") ; require(multcomp)
#--------------------------------
# get your current name 
#--------------------------------
getUsername <- function(){
  name <- Sys.info()[["user"]]
  return(name)
}
#--------------------------------
# the code below is adapted to the three persons who currently 
# load this script
# TODO: be more generic
# It is necessary to create a folder, your code is currently stored in
#--------------------------------------------------
# FOLDER>WGEELgit>R>recruitment>recruitment_analysis.Rnw
#---------------------------------------------------
# This will be automatically set when pulling code from git
# WGEELgit is the local name you have chosen for the git repository,
# FOLDER is the directory where you have stored the git code
# So you need to create a directory to store data and figures besides this 
# directory, like this
# FOLDER>datawgeel>recruitement>2019>data
# FOLDER>datawgeel>recruitement>2019>image
# FOLDER>datawgeel>recruitement>2019>table
# here 2019 is the current year of recruitment (I have several folders one for each year)
# the reason for this is that we don't want to put data or figures in the git.
#--------------------------------

if(getUsername() == 'cedric.briand')
{
  # I have two password in the R.site of c:/program files/R... so I don't need no prompt

  #baseODBC=c("wgeel","wgeel",passwordwgeel) #"w3.eptb-vilaine.fr" "localhost" "wgeel" "wgeel_distant" 
  options(sqldf.RPostgreSQL.user = "wgeel", 
	  sqldf.RPostgreSQL.password = passwordwgeel,
	  sqldf.RPostgreSQL.dbname = "wgeel",
	  sqldf.RPostgreSQL.host = "localhost", # "localhost"
	  sqldf.RPostgreSQL.port = 5435) # 5435 launch the ssh tunnel
  setwd("C:/workspace/gitwgeel/R/recruitment")
  
  wd <- getwd()
  wddata <- gsub("C:/workspace/gitwgeel/R","C:/workspace/wgeeldata",wd)
  datawd <- str_c(wddata,"/",CY,"/data/")
  imgwd <- str_c(wddata,"/",CY,"/image/")
  tabwd <- str_c(wddata,"/",CY,"/table/")
  shpwd <- str_c("C:/workspace/wgeeldata/shp/") 
  shinywd <- "C:/workspace/gitwgeel/R/shiny_data_visualisation/shiny_dv/data/recruitment/"
}
if(getUsername() == 'lbeaulaton')
{
  getpassword<-function(){  
	require(tcltk);  
	wnd<-tktoplevel();tclVar("")->passVar;  
	#Label  
	tkgrid(tklabel(wnd,text="Enter password:"));  
	#Password box  
	tkgrid(tkentry(wnd,textvariable=passVar,show="*")->passBox);  
	#Hitting return will also submit password  
	tkbind(passBox,"<Return>",function() tkdestroy(wnd));  
	#OK button  
	tkgrid(tkbutton(wnd,text="OK",command=function() tkdestroy(wnd)));  
	#Wait for user to click OK  
	tkwait.window(wnd);  
	password<-tclvalue(passVar);  
	return(password);  
  }  
  if (!exists("password"))  { 
	password<-getpassword()
  }
  #baseODBC=c("wgeel","postgres",password)
  options(sqldf.RPostgreSQL.user = "lolo", 
	  sqldf.RPostgreSQL.password = password,
	  sqldf.RPostgreSQL.dbname = "wgeel_ices",
	  sqldf.RPostgreSQL.host = "localhost", 
	  sqldf.RPostgreSQL.port = 5432)
  
  setwd(str_c(getwd(), "/R/recruitment"))
  wd=getwd()
  
  wddata <- "/home/lbeaulaton/Documents/ANGUILLE/ICES/WGEEL/Ranalysis"
  datawd<-str_c(wddata,"/",CY,"/data/")
  imgwd<-str_c(wddata,"/",CY,"/image/")
  tabwd<-str_c(wddata,"/",CY,"/table/")
  shpwd="/home/lbeaulaton/Documents/ANGUILLE/ICES/WGEEL/SIG/" # emu, rbd, country
}

if(getUsername() == 'EDIAZ')
{
  getpassword<-function(){  
	require(tcltk);  
	wnd<-tktoplevel();tclVar("")->passVar;  
	#Label  
	tkgrid(tklabel(wnd,text="Enter password:"));  
	#Password box  
	tkgrid(tkentry(wnd,textvariable=passVar,show="*")->passBox);  
	#Hitting return will also submit password  
	tkbind(passBox,"<Return>",function() tkdestroy(wnd));  
	#OK button  
	tkgrid(tkbutton(wnd,text="OK",command=function() tkdestroy(wnd)));  
	#Wait for user to click OK  
	tkwait.window(wnd);  
	password<-tclvalue(passVar);  
	return(password);  
  }  
  if (!exists("password"))  { 
	password<-getpassword()
  }
  baseODBC=c("wgeel","postgres",password)
  options(sqldf.RPostgreSQL.user = "postgres", 
	  sqldf.RPostgreSQL.password = password,
	  sqldf.RPostgreSQL.dbname = "wgeel",
	  sqldf.RPostgreSQL.host = "w3.eptb-vilaine.fr", 
	  sqldf.RPostgreSQL.port = 5432)
  setwd("C:/Users/ediaz/workspace/wgeel/sweave")
  wd<-getwd()
  wddata<-gsub("wgeel","wgeeldata",wd) # replacing the path to wgeel by wgeeldata ...
  
  datawd<-str_c(wddata,"/",CY,"/data/")
  imgwd<-str_c(wddata,"/",CY,"/image/")
  tabwd<-str_c(wddata,"/",CY,"/table/")
  shpwd=str_c(wddata,"/wgeel2013/emu/") 
}
# some of the functions used later in that script :
source('utility_functions.R')
graphics.off() # close all graphics devices
# the results will be stored in a list, when I first run the program,
# on the second run this list will be loaded and I can avoid some steps in the calculation
# by setting the chunks as eval=FALSE
vv<-list()
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% this is the preamble of the latex file
% it is used to load the packages necessary to the analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[pdftex,11pt,a4paper]{report}
\usepackage[pdftex]{graphicx}
\usepackage[utf8]{inputenc} %encodage du fichier source
%\usepackage[T1]{fontenc}  %gestion des accents (pour les pdf) 
%\usepackage[swedish]{babel}
\usepackage{Sweave}
\usepackage{float}
\usepackage[left=3cm, right=3cm, top=2cm, bottom=2cm]{geometry}
\usepackage{pdflscape}% to rotate the table
\geometry{dvips,a4paper,hmargin=2.5cm,vmargin=2.5cm}
\setcounter{secnumdepth}{10}
\usepackage{hyperref} %managing hyperlinks
\hypersetup{
     backref=true,    %permet d'ajouter des liens dans...
     pagebackref=true,%...les bibliographies
     hyperindex=true, %ajoute des liens dans les index.
     colorlinks=true, %colorise les liens
     breaklinks=true, %permet le retour à la ligne dans les liens trop longs
     urlcolor= blue,  %couleur des hyperliens
     linkcolor= blue, %couleur des liens internes
     bookmarks=true,  %créé des signets pour Acrobat
     bookmarksopen=true,            %si les signets Acrobat sont créés,
                                    %les afficher complètement.
     pdftitle={WGEEL recruitment analysis output}, %informations apparaissant dans
     pdfauthor={Cédric Briand},     %dans les informations du document
     pdfsubject={Glass eel recruitment}          %sous Acrobat
     pdfkeywords={Glass eel, WGEEL, recruitment, time-series, ICES}
}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,usenames,dvipsnames]{xcolor}
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
% this is where I'm storing files locally
\graphicspath{{\Sexpr{str_c(imgwd, "/")}}} 
% TO UPDATE TO THE NEW YEAR
% DO REPLACE FOR INSTANCE F:/workspace/wgeeldata/sweave/2016/table by F:/workspace/wgeeldata/sweave/2019/table
%%%%%%%%%%%%%%%%%%%%%%%%%% END OF THE PREAMBLE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\bibliographystyle{plain}
\title{ Analysis of recruitment trend}
\author{EIFAAC/ICES/GFCM Working Group on Eel}
\date\today
\maketitle
\newpage
\tableofcontents
\subsection*{}
% use this if the chair wants a different chapter heading
%\addtocounter{chapter}{3} % this will set initial chapter counter to  4
%======================================================================
\addtocounter{chapter}{1}
\chapter{Report on developments in the state of the European eel (Anguilla
anguilla) stock, the fisheries on it and other anthropogenic impacts.}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%*******Here put eval=FALSE if you plan to use Rdata *********************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<load_database, echo=FALSE, fig=FALSE, eval=FALSE,results=hide>>=
# In this chunk everything will be loaded. 
# The data selection is made tranparently later in the chunk "select_series"
# This chunks uses the RequeteODBC connection object from stacomirtools and sqldf
# an odbc link must be configured to the database : i.e. you must have the postgres
# database available, and an ODBC link pointing to the database.
# If you don't and still want to run this script, ask Cédric cedric.briand@eptb-vilaine.fr
# he will send you the Rdata saved during this chunk.


##########################"
# Description of the series -------------------------------
##########################

query ='select 
     ser_id, ser_order, ser_nameshort, ser_namelong, ser_typ_id, ser_effort_uni_code,
     ser_comment, ser_uni_code, ser_lfs_code, ser_hty_code, ser_locationdescription,
      ser_emu_nameshort, ser_cou_code, ser_area_division, ser_x, ser_y,             
     ser_sam_id, ser_qal_id, ser_qal_comment,     
     "tblCodeID", "Station_Code", "Country", "Organisation", "Station_Name",       
     cou_code, cou_country, cou_order, cou_iso3code,
     lfs_code, lfs_name, lfs_definition,              
     ocean,  subocean, f_area, f_subarea,  f_division
     from datawg.t_series_ser 
	left join ref.tr_station on ser_tblcodeid=tr_station."tblCodeID"
	left join ref.tr_country_cou on cou_code=ser_cou_code 
	left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
	left join ref.tr_faoareas on ser_area_division=f_division
	where ser_typ_id=1'

R_stations= sqldf(query)


##########################
# Main data from the series -------------------------------
##########################

query='SELECT 
	das_id,
	das_value,       
	das_year,
	das_comment,
	/* 
	-- below those are data on effort, not used yet
	
	das_effort, 
	ser_effort_uni_code,       
	das_last_update,
	*/
	/* 
	-- this is the id on quality, used from 2018
	-- to remove the data with problems on quality from the series
	-- see WKEEKDATA (2018)
	das_qal_id,
	*/ 
	ser_id,            
	ser_order,
	ser_nameshort,
	ser_area_division,
	ser_qal_id,
	/* 
	-- this is the id on quality at the level of individual lines of data
	-- checks are done later to ensure provide a summary of the number of 0 (missing data),
    -- 3 data discarded, 4 used but with doubts....
	*/ 
	das_qal_id,
    das_last_update,
	f_subarea,
	lfs_code,          
	lfs_name
	from datawg.t_dataseries_das 
	join datawg.t_series_ser on das_ser_id=ser_id
	left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
	left join ref.tr_faoareas on ser_area_division=f_division
	where ser_typ_id=1'

wger_init=sqldf(query) # (wge)el (r)ecruitment data
wger_init<-chnames(wger_init,
	c("das_id","das_value","das_year","ser_nameshort","ser_area_division","lfs_name"),
	c("id","value","year","site","area_division","lifestage"))
############################################################################
# Rebuilding areas used by wgeel (North Sea, Elswhere Europe) from area_divisions
# See Ices (2008) for the reason why we need to do that
# We cannot use just one series, as the series from the North Sea have dropped more
# rapidly than the others, and are now at a much lower level.
# Some of that drop might be explained by decreasing catch in some of the semi-commercial
# catch and trap and transport series (Ems, Vidaa) but it also concerns fully scientific
# Estimates....
###############################################################################
wger_init[,"area"]<-NA
# below these are area used in some of the scripts see wgeel 2008 and Willem's Analysis 
# but currently wgeel only uses two areas so the following script is kept for memory
# but mostly useless
wger_init$area[wger_init$f_subarea%in%'27.4']<-"North Sea"
wger_init$area[wger_init$f_subarea%in%'27.3']<-"Baltic"
wger_init$area[wger_init$f_subarea%in%c('27.6','27.7','27.8','27.9')]<-"Atlantic"
wger_init$area[wger_init$f_subarea%in%c('37.1','37.2','37.3')]<-"Mediterranean Sea"
wger_init[wger_init$area%in%c("Atlantic","Mediterranean Sea"),"area"]<-"Elsewhere Europe"
# We consider that the series of glass eel recruitment in the Baltic are influenced
# similarly in the Baltic and North Sea. This has no effect on Baltic data
wger_init[wger_init$area%in%c("Baltic"),"area"]<-"North Sea"

#check if all series have been assign to an area
if(sum(is.na(wger_init$area))>0) stop("At least one series has not been affected to an area")

wger_init$area<-as.factor(wger_init$area)
# We will also need this for summary tables per recruitment site, here we go straight to 
# the result
R_stations[,"area"]<-NA
R_stations$area[R_stations$f_subarea%in%c('27.4','27.3')]<-"North Sea"
stopifnot(all(!is.na(R_stations$f_subarea)))
# the rest (currently NA) are Elwhere Europe
R_stations$area[is.na(R_stations$area)]<-"Elsewhere Europe"
# Check that there was no error in the query (while joining foreign table)
stopifnot(all(!duplicated(wger_init$id)))
# creates some variables
wger_init$decade=factor(trunc(wger_init$year/10)*10)
wger_init$year_f=factor(wger_init$year)
wger_init$decade=factor(wger_init$decade,level=sort(unique(as.numeric(as.character(wger_init$decade)))))
wger_init$ldata=log(wger_init$value)
wger_init$lifestage=as.factor(wger_init$lifestage)

# This is a view (like the result of a query) showing a summary of each series, including first year, last year,
# and duration
statseries<-sqldf('select site,namelong,min,max,duration,missing,life_stage,sampling_type,unit,habitat_type,"order",series_kept
 from datawg.series_summary where ser_typ_id=1')
# these data will 
save(wger_init,file=str_c(datawd,"wger_init.Rdata"))
save(statseries,file=str_c(datawd,"statseries.Rdata"))
save(R_stations,file=str_c(datawd,"R_stations.Rdata"))

save(wger_init,file=str_c(shinywd,"wger_init.Rdata"))
save(statseries,file=str_c(shinywd,"statseries.Rdata"))
save(R_stations,file=str_c(shinywd,"R_stations.Rdata"))
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<< load_rdata, echo=FALSE, fig=FALSE, eval=TRUE, results=hide>>=
# In this rchunk we load the data even if there is no connection to the database
load(file=str_c(datawd,"wger_init.Rdata"))
load(file=str_c(datawd,"statseries.Rdata"))
load(file=str_c(datawd,"R_stations.Rdata"))
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 				SERIES SELECTION AND STATISTICS ABOUT DATA ENTRY 
% the statistics about the series are usefull while filling in new data, to check
% which series have been already entered and which still need to be
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<< select_series, echo=FALSE, fig=FALSE, eval=TRUE, results=hide >>=

# wger_init is used to keep the "whole" dataset, just in case we mess with it afterwards
wger <- wger_init

vv$nb_series_init<-length(unique(wger$site)) # this is the true number at the beginning
# 2018 removing series which are not of the best quality;
wger<-wger[wger$ser_qal_id==1,]
#TODO calculate which series longer than 10 which have qal 0, issue a message
vv$nb_series_init_qual1<-length(unique(wger$site))

# check on series discarded -----------------------------------------------

# So far I haven't automated the decision rule to only integrate new series if they
# are more than 10 year long. So each year we have to check. Some of the series have been
# discared for other reasons and this is stated in column eel_qal_comment of the t_series_ser table

wgerdiscarded<-wger_init[wger_init$ser_qal_id!=1,]
# series marked as "0" might have a very low value but not included in the analysis, here replaced by NA
wgerdiscarded$value[wgerdiscarded$das_qal_id==0]<-NA
# storing this information in a list for eventual later display and check
vv$length_discarded <- tapply(wgerdiscarded$value,wgerdiscarded$site,function(X) sum(!is.na(X)))
# below comments for 2018 after checking the series
# Farp (Farpener Bach DE) 11 years long enough but stocking influence 
# DoFp (Fyke on yellow eel) 13 years but fyke nets yellow catch, not really recruitment
# SeHM (35 year) duplicates

# Treating individual eel_qal_comment on the series
# In some series and for some years, there might be a value, and a good reason not to
# consider that value, e.g. hydropower station on which the pass is built only operated after
# the recruitment season, or local conditions making it impossible to evaluate recruitment.
# Series with no data have das_qal_id = 0
# Series with data to be removed have eel_qal_id = 3
# Series about which we have serious doubts but that we choose to keep have eel_qal_id = 4

# All values labelled 0 must have no data 
should_be_na <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==0,c("value")]
should_be_na_id <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==0,c("id")]
wger[!is.na(wger$das_qal_id)&wger$das_qal_id==0,c("value")]
if (! all(is.na(
        should_be_na
    )))
stop("Rows with id", paste(should_be_na_id[which(!is.na(should_be_na))],collapse=","), 
    " with qal_id 0 should be NA")

# Checking series with eel_qal_id 3 (wrong data to be ignored) -------------------------------------

removed_id <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==3,c("id")] 
removed_year <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==3,c("year")]
removed_site <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==3,c("site")]
warnings("Rows with ids: ", paste(removed_id,collapse=","),     
    " sites: ", paste(removed_site,collapse=","),     
    " years: ", paste(removed_year,collapse=","),     
    " with qal_id = 3 removed from analysis")
vv$qual_id_3_removed <- list()
vv$qual_id_3_removed$length<-length(removed_id)
vv$qual_id_3_removed$year<-removed_year
vv$qual_id_3_removed$site<-removed_site
# For those series, values are replaced with NA -----------------------------------------------------

wger[!is.na(wger$das_qal_id)&wger$das_qal_id==3,c("value")] <- NA
  #########################################################################
# standardizing with 2000-2009
# this was a question asked by ACFM ? 2014 ?
# so it's still done, we produce a graph but don't show it
# as it might confuse the reader
  ##########################################################################
  
mdata=wger[wger$year>=2000 & wger$year<2010,]
std_site<-unique(mdata$site[order(mdata$site)])
# length(std_site) 
site<-unique(wger$site[order(wger$site)])
# length(site)  #52
unused_series_2000_2009 = site[!site%in%std_site] # series not having data between 2000 and 2009 # "Vida" "YFS1" 
vv$sc_2000_2009_unused_series<-unused_series_2000_2009
vv$sc_2000_2009_nb<-vv$nb_series_init_qual1-length(vv$sc_2000_2009_unused_series)
#add a column to R_station for flagging unused series
R_stations$unused_2000_2009 = FALSE
R_stations[R_stations$rec_nameshort %in% unused_series_2000_2009, "unused_2000_2009"] = TRUE
#ex(std_site)
# Inag and Maig left out from the analysis 
mean_site=data.frame(mean_2000_2009=tapply(mdata$value,mdata$site,mean,na.rm=TRUE))
mean_site$site=rownames(mean_site)
wger=merge(wger,mean_site,by="site",all.x=TRUE,all.y=FALSE) # here we loose the two stations Inag and Maig and also Frémur
wger$value_std_2000_2009=wger$value/wger$mean_2000_2009

#########################################################################
#standardizing with mean from 1979-1994
##########################################################################

mdata=wger[wger$year>=1979 & wger$year<1994,]
std_site<-unique(mdata$site[order(mdata$site)])
# length(std_site) # 45
site<-unique(wger$site[order(wger$site)])
# length(site) #49
unused_series_1979_1994 = site[!site%in%std_site] # "Bres" "Fre"  "Inag" "Klit" "Maig" "Nors" "Sle"  "Vac"
vv$sc_1979_1994_unused_series<-unused_series_1979_1994
vv$sc_1979_1994_nb=vv$nb_series_init_qual1-length(vv$sc_1979_1994_unused_series)
#add a column to R_station for flagging unused series
R_stations$unused_1979_1994 = FALSE
R_stations[R_stations$rec_nameshort %in% unused_series_1979_1994, "unused_1979_1994"] = TRUE
mean_site=data.frame(mean_1979_1994=tapply(mdata$value,mdata$site,mean,na.rm=TRUE))
mean_site$site=rownames(mean_site)
wger=merge(wger,mean_site,by="site",all.x=TRUE,all.y=FALSE) 
wger$value_std_1979_1994=wger$value/wger$mean_1979_1994

#########################################################################
#standardizing with mean (all data)
##########################################################################

mean_site=data.frame(mean = tapply(wger$value,wger$site,mean,na.rm=TRUE))
mean_site$site=rownames(mean_site)
wger=merge(wger,mean_site,by="site",all.x=TRUE,all.y=FALSE) 
wger$value_std=wger$value/wger$mean


#########################################################################
#separating glass eel and yellow eels
##########################################################################


glass_eel_yoy=wger[wger$lifestage!="yellow eel" & wger$year>1959,] #glass eel and yoy
older=wger[wger$lifestage=="yellow eel" & wger$year>1949,] # Advice Drafting 2017 asks to 
# give from 1949 to be consistent with previous years

##########################################################################
# Some statistics for later use, nb of year per series
#########################################################################

nb_year=colSums(ftable(xtabs(formula = value_std_1979_1994~year+site,data=wger))>0)
names(nb_year)=colnames(xtabs(formula = value_std_1979_1994~year+site,data=wger))

###############################################################
# some other statistics used there
###############################################################

nb_series_glass_eel<-length(unique(glass_eel_yoy$site)) # this will be reported in the pdf later
vv$nb_series_glass_eel<-nb_series_glass_eel
nb_series_older<-length(unique(older$site)) # this will be reported in the pdf later
vv$nb_series_older<-nb_series_older
nb_series_final=nb_series_glass_eel+nb_series_older
vv$nb_series_final<-nb_series_final


###############################################################
# Finally saving the data
###############################################################

save(wger,file=paste0(datawd,"wger.Rdata"))
save(older,file=paste0(datawd,"older.Rdata"))
save(glass_eel_yoy,file=paste0(datawd,"glass_eel_yoy.Rdata"))

save(wger,file=paste0(shinywd,"wger.Rdata"))
save(older,file=paste0(shinywd,"older.Rdata"))
save(glass_eel_yoy,file=paste0(shinywd,"glass_eel_yoy.Rdata"))


#load(paste(datawd,"wger.Rdata",sep="/"))
#load(paste(datawd,"older.Rdata",sep="/"))
#load(paste(datawd,"glass_eel_yoy.Rdata",sep="/"))
write.table(glass_eel_yoy,file=str_c(datawd,"glass_eel_yoy.csv"),sep=";")
write.table(older,file=str_c(datawd,"older.csv"),sep=";")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				THIS CHUNK CREATES THE TABLES	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<< table_series,echo=FALSE, eval=TRUE,fig=FALSE, results=hide>>=
last_year<-tapply(wger$year,wger$site,function(X) max(X))
#stations updated to",CY
R_stations$areashort<-"EE"
R_stations$areashort[R_stations$area=="North Sea"]<-"NS"
R_stations$ser_namelong <- iconv(R_stations$ser_namelong,"UTF8")
series_CY<-R_stations[R_stations$ser_nameshort%in%names(last_year[last_year==CY]),
    c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division","ser_order")]
series_CY<-series_CY[order(series_CY$ser_order),-ncol(series_CY)]
vv$nCY<-nrow(series_CY) # number of series updated to the current year (for later use)
vv$nCYG<-nrow(series_CY[series_CY$ser_lfs_code=="G",]) # number of series with glass eel updated to the current year
vv$nCYGY<-nrow(series_CY[series_CY$ser_lfs_code=="GY",]) # number of series with glass eel updated to the current year
vv$nCYY<-nrow(series_CY[series_CY$ser_lfs_code=="Y",]) # number of series with yellow eel (only) updated to the current year

#"stations updated to",CY-1
series_CYm1<-R_stations[R_stations$ser_nameshort%in%names(last_year[last_year==CY-1]),
    c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division","ser_order")]
series_CYm1<-series_CYm1[order(series_CYm1$ser_order),-ncol(series_CYm1)]
vv$nCYm1<-nrow(series_CYm1) # number series updated last year only (and not this year)
vv$nCYm1G<-nrow(series_CYm1[grepl("G",series_CYm1$ser_lfs_code),]) # same for glass eel 
vv$nCYm1GY<-nrow(series_CYm1[grepl("GY",series_CYm1$ser_lfs_code),]) # same for glass eel 
vv$nCYm1Y<-nrow(series_CYm1[series_CYm1$ser_lfs_code=="Y",]) # same for yellow eel only

# Series that have not been updated for two years
lost_ones<-last_year[last_year<CY-1]
d_lost_ones<-data.frame("site"=names(lost_ones),"year"=lost_ones) # data frame
series_lost<-merge(
	R_stations[R_stations$ser_nameshort%in%names(lost_ones),c(c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division"))],
	d_lost_ones,
	by.y="site",by.x="ser_nameshort")
series_lost<-series_lost[order(series_lost$year),]
vv$nseries_lost<-nrow(series_lost) # number of series not updated for the two last years
vv$nseries_lostG<-nrow(series_lost[grepl("G",series_lost$ser_lfs_code),])
vv$nseries_lostY<-nrow(series_lost[series_lost$ser_lfs_code=="Y",])
vv$nseries_lostGY<-nrow(series_lost[series_lost$ser_lfs_code=="GY",])
#xtable of current year series


#------------------------------------------------------
# we use xtable to transform the table to a latex format
#------------------------------------------------------


colnames(series_CY)<-str_c("\\scshape{",c("Site","Name","Coun.","Stage","Area","Division"),"}")

xseries_CY <- xtable(x = series_CY,
	label = "table_seriesCY",
	caption = str_c("Series updated to ",CY),
	align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}"))
print(xseries_CY, file = str_c(	tabwd,"/table_seriesCY.tex"),
	table.placement = "htbp",
	caption.placement = "top",
	sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
	NA.string = ".",
	tabular.environment="tabularx",
	width="\\textwidth",
	include.rownames=FALSE
)
#------------------------------------------------------
# xtable of series current year minus one
#------------------------------------------------------
colnames(series_CYm1)<-str_c("\\scshape{",c("Site","Name","Coun.","Stage","Area","Division"),"}")
xseries_CYm1 <- xtable(x = series_CYm1,
	label = str_c("table_seriesCYm1"),
	caption = str_c("Series updated to ",CY-1),
	align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}"))

print(xseries_CYm1, 
	file = str_c(tabwd,"/table_seriesCYm1.tex"),
	table.placement = "htbp",
	caption.placement = "top",
	sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
	NA.string = ".",
	tabular.environment="tabularx",
	width="\\textwidth",
	include.rownames=FALSE
)
#------------------------------------------------------
# xtable of series that have not been udpated
#------------------------------------------------------
colnames(series_lost)<-str_c("\\scshape{",c("Site","Name","Coun.","Stage","Area","Division","Last Year"),"}")
xseries_lost <- xtable(x = series_lost,
	label = str_c("table_serieslost"),
	caption = str_c("Series stopped or not updated to ",CY-1),
	align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}","p{1.2cm}"))
print(xseries_lost, 
	file = str_c(tabwd,"/table_serieslost.tex"),
	table.placement = "htbp",
	caption.placement = "top",
	sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
	NA.string = ".",
	tabular.environment="tabularx",
	width="\\textwidth",
	include.rownames=FALSE
)
# number of series per area per year
area_year=table(glass_eel_yoy$year,glass_eel_yoy$area)
# number of series per stage per year
n_y_lfs<-reshape2::dcast(wger,year~lifestage,length,value.var="year")
n_y_lfs$sum<-rowSums(n_y_lfs[,c(2:4)])
colnames(n_y_lfs)<-c("year","glass","glass+yellow","yellow","sum")
rownames(n_y_lfs)<-n_y_lfs$"year"
#xn_y_lfs <- xtable(x = n_y_lfs, 
#		label = "table_n_y_lfs",
#		caption = str_c("Numer of series per stage per year"))
#print(xn_y_lfs, file = str_c(tabwd,"/table_n_y_lfs.tex"), 
#		table.placement = "htbp",
#		caption.placement = "top",
#		NA.string = ".")

#n_area_styp<-reshape2::dcast(wger,area~sampling_type,length,value.var="area")
#n_y_area<-reshape2::dcast(wger,year~area,length,value.var="area")
#n_y_area$sum<-rowSums(n_y_area[,c(2,3)])
#rownames(n_y_area)<-n_y_area$year
##xn_y_area <- xtable(x = n_y_area, 
##		label = str_c("table_n_y_area"),
##		caption = str_c("Number of series per geographical area per year"),
##		digits=0)
##print(xn_y_area, 
##		file = str_c(tabwd,"/table_n_y_area.tex"), 
##		table.placement = "htbp",
##		caption.placement = "top",
##		NA.string = ".")

printstatseries<-statseries[,c(1,3,4,5,6,7,8,9,10,11,12)]
printstatseries$sampling_type[printstatseries$sampling_type=="scientific estimate"]<-"sci. surv."
printstatseries$sampling_type[grep("trap",printstatseries$sampling_type)]<-"trap"
printstatseries$sampling_type[printstatseries$sampling_type=="commercial catch"]<-"com. catch"
printstatseries$sampling_type[printstatseries$sampling_type=="commercial CPUE"]<-"com. cpue"
column_to_import<-R_stations[,c("ser_nameshort","areashort")]
printstatseries<-merge(printstatseries,column_to_import,by.x="site",by.y="ser_nameshort")
printstatseries<-printstatseries[order(printstatseries$order),c(1,12,2:9,11)]
colnames(printstatseries)<-
	c("code","area","min","max","n+","n-", "life stage",      
		"sampling type","unit","habitat","kept")
xstatseries <- xtable(x = printstatseries[1:20,], 
	label = str_c("statseries"),
	caption = str_c("Short description of the sampling sites for European eel recruitment data. Area: NS = North Sea, EE = Elsewhere Europe. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses."),
	align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
	digits=0)
print(xstatseries , 
	file = str_c(tabwd,"/table_statseries.tex"),
	table.placement = "htbp",
	caption.placement = "top",
	sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
	NA.string = ".",
	include.rownames=FALSE
)
xstatseries <- xtable(x = printstatseries[21:40,], 
	label = str_c("statseries"),
	caption = str_c("Short description of the recruitment sites (continued)"),
	align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
	digits=0)
print(xstatseries , 
	file = str_c(tabwd,"/table_statseries1.tex"),
	table.placement = "htbp",
	caption.placement = "top",
	sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
	NA.string = ".",
	include.rownames=FALSE
)
xstatseries1 <- xtable(x = printstatseries[41:nrow(printstatseries),], 
	label = str_c("statseries"),
	caption = str_c("Short description of the recruitment sites (continued-yellow eel series) "),
	align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
	digits=0)
print(xstatseries1 , 
	file = str_c(tabwd,"/table_statseries2.tex"),
	table.placement = "htbp",
	caption.placement = "top",
	sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
	NA.string = ".",
	include.rownames=FALSE
)
################################################################
# some additional stats for the report
#################################################################
# in which year has there been the largest number of glass eel (or apparented) series ?
yearmaxglasseel<-n_y_lfs$year[which(max(n_y_lfs$"glass"+n_y_lfs$"glass+yellow")==n_y_lfs$"glass"+n_y_lfs$"glass+yellow")]
# and for how long ?
nbmaxglasseel<-max(n_y_lfs$"glass"+n_y_lfs$"glass+yellow")
# storing this in our nice list
vv$yearmaxglasseel<-yearmaxglasseel
vv$nbmaxglasseel<-nbmaxglasseel
vv$nbcurrentglasseel<-n_y_lfs$"glass"[n_y_lfs$year==CY]+n_y_lfs$"glass+yellow"[n_y_lfs$year==CY]
# same for yellow eel
yearmaxyellow<-n_y_lfs$year[which(max(n_y_lfs$"yellow")==n_y_lfs$"yellow")]
nbmaxyellow<-max(n_y_lfs$"yellow")
vv$yearmaxyellow<-yearmaxyellow
vv$nbmaxyellow<-nbmaxyellow
vv$nbcurrentyellow<-n_y_lfs$"yellow"[n_y_lfs$year==CY]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<< figure_series, echo=FALSE,  eval=FALSE, results=hide >>=

figure2<-function(){
  par(mar=c(4,4,0,0)+.5)
  matplot(rownames(table(wger$year,wger$lifestage)),table(wger$year,wger$lifestage),type="b",lty=c(1,2,3),pch=c(16,17,18),col=c("black","black","grey"),xlab="year",ylab="number of series")
  legend("topleft",legend=colnames(table(wger$year,wger$lifestage)),lty=c(1,2,3),pch=c(16,17,18),col=c("black","black","grey"))
}

figname<-"figure2"
# {{{{{{{{{{{{{{{{{{{{{{{{{
jpeg(filename = paste(imgwd,"/",figname,".jpeg",sep="")) #, width =480, height = 600
figure2()
rien<-dev.off()
# {{{{{{{{{{{{{{{{{{{{{{{{{
bmp(filename = paste(imgwd,"/",figname,".bmp",sep=""))
figure2()
rien<-dev.off()
# {{{{{{{{{{{{{{{{{{{{{{{{{
png(filename = paste(imgwd,"/",figname,".png",sep=""))
figure2()
rien<-dev.off()
# {{{{{{{{{{{{{{{{{{{{{{{{{


@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<tableswgeel,echo=FALSE, eval=FALSE,results=hide>>=
# THIS R CHUNCK IS USED ONCE AT THE END TO GENERATE THE TABLES.
## This will fail if saved twice, run at the end of the working group to generate the table of values
dat<-wger_init[order(wger_init$ser_order,wger_init$year),]
dat$year=as.factor(dat$year)
stopifnot(length(unique(dat$ser_order))== length(unique(dat$ser_id)))
# this will create the table to export to excel with all raw data
tab1<-reshape2::dcast(dat,year~ser_order,value.var="value")
tab1[,2:ncol(tab1)]=round(tab1[,2:ncol(tab1)],2)
colnames(tab1)<-c("year",statseries$site)
tab1[,1]<-as.character(tab1[,1])
first_line<-c("kept",statseries$series_kept)
tab1<-rbind(first_line,tab1)
createxl<-function(data=tab1,sheet="recruitment_series"){
  library("XLConnect")
  xls.file<-str_c(datawd,"table_rec2019.xls")
  wb = loadWorkbook(xls.file, create = TRUE)
  createSheet(wb,sheet)
  writeWorksheet (wb , data , sheet=sheet ,header = TRUE )
  saveWorkbook(wb)
  #cat("travail terminé\n")
}
createxl(data=tab1,sheet="recruitment_series")
createxl(data=statseries,sheet="series_description")

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Data sources}
\section{Recruitment}

In this section, the latest trend in glass and yellow eel recruitment are
adressed. The time-series data are derived from fishery-dependent sources
(i.e. catch records) and also from fishery-independent surveys across much of
the geographic range of European eel.  The
stages are categorized as glass eel (G), mixture of glass eel and young
yellow eel dominated by recruits from the year (GY) and older yellow eel (Y)
recruiting to continental habitats (Dekker, 2002). The yellow eel series might 
consist of yellow eel of several ages. 
This is certainly the case for all series from the Baltic, and sites located well into freshwater. 

The glass eel recruitment time-series have been grouped into two geographical
areas: 'continental North Sea' (NS) and 'Elsewhere Europe' (EE) (Figure
\ref{figure1}). 

{\setlength{\fboxsep}{10pt}
\noindent\fbox{%
    \parbox{\textwidth}{%
    \textit{
    Extract from the 2010 report of the WGEEL (ICES, 2010b, p19) explaining the
    split into two recruitment indices: it was demonstrated that a sharper decrease occurred 
    in the North Sea recruitment series. Repeatedly, new analyses have been done to check this, 
    and it was decided to keep that split. The variability within each geographical unit is high, 
    and there is no clear pattern in the trend of recruitment between the series, except for the North
    Sea which stands apart with series demonstrating a much more pronounced declining trend, 
    as demonstrated by the GLM analysis. This sharper decline in recruitment
    is observed for series in the Kattegat (YFS2), a scientific young fish survey, 
    on the Dutch coast (Ems, Rhine IJmuiden, Stellandam) and in Denmark (Vidaa)
    and Norway (Imsa).
    Surprisingly, this sharper decline is not observed in the Baltic area. 
    The decline might, in some places, be explained by diminishing fishing effort (Ems, Vidaa) 
    but not for the scientific estimates (YFS2, Rhine IJmuiden, Ijser,
    Stellendam).
    It must also be noted that other stations, geographically close to the other Dutch recruitment stations
    (Lauwersoog, Katwijk) and the Ringhals nuclear power station series, have similar trends to the mean of
    the other European series. 
    An alternative model was tested using log(x+$\alpha$) transformed values, $\epsilon$ as a gaussian error, 
    and identity link, with a negligible when compared with the minimum value yields almost no difference in the results.
    Also an analysis on a more limited time frame 1975-2009 yielded similar results with the North Sea stations
    standing apart from the others. 
    }%
    }%
}
}

Bornarel et al. (2017) adapted the Glass Eel Recruitment Estimation Model (GEREM) 
to estimate annual recruitment (i) at the river catchment level, a scale for which data are available, 
(ii) at an intermediate scale (6 European regions), and (iii) at a larger scale (Europe). 
Results confirmed an overall recruitment decline and confirmed a more pronounced decline
in the North Sea area compared to the Elsewhere Europe area (after ICES, 2010b).
.

The WGEEL has collated information on recruitment from
\Sexpr{sn(vv[["nb_series_init"]])} time-series. Some time-series date back to the
beginning of 20th century (yellow eel, Göta Älv, Sweden) or 1920 (glass eel,
Loire, France). Among those series \Sexpr{sn(vv[["nb_series_init_qual1"]])} have been
selected for further analysis in the wgeel indices, see details on data
selection and processing below). Depending on the period on which we
standardized, the number of series really used can be lower and are given for
each analysis. 

%==================================================
\begin{figure}[htbp]
\centering
\includegraphics[width=0.7\textwidth]{figure1.png}
\caption{Map of recruitment sampling stations, color according to stage (grey =
G and GY) yellow = Y.}
\label{figure1}
\end{figure}
%==========================================

\subsection{Details on data selection and processing}

Out of \Sexpr{sn(vv[["nb_series_final"]])}, \Sexpr{sn(vv[["nb_series_init"]])}
series were not used in the analysis. Three rules have been used for this selection
procedure.
\begin{enumerate}
\item The first rule is to keep only one series at one location when two
series from different source display different information. For instance, the longest series has been kept for the severn (Severn EA) and the other (Severn
HMRC) has been dropped from the list, as it was considered a double being based
on the same fishery. \textcolor{Plum}{TODO work on Minho sp and Minho
pt. and Gironde....}
\item The second rule is not to include a series when it is too short. It was
decided in 2019 to include the practical rule that series of less than 10
years, should not be kept. They are still updated in the database untill they
can be included. \textcolor{Plum}{But clarify now what we are going to do
when there are missing years....} 
\item Finally, it was also decided to discard
recruitment series that were obviously biased by restocking e.g. Farpener Bach
in Germany.
\end{enumerate}


Among the time-series based on trap indices, some have reported
preliminary data for \Sexpr{CY} as their trapping season had not
finished. \textbf{As usual, the indices given for \Sexpr{CY} must be considered
as provisional especially those for the yellow eel.}



 %====================================
	\input{\Sexpr{str_c(tabwd,"/table_statseries.tex")}}
 %====================================

 %====================================
	\input{\Sexpr{str_c(tabwd,"/table_statseries1.tex")}}
 %====================================F

 %====================================
	\input{\Sexpr{str_c(tabwd,"/table_statseries2.tex")}}
 %====================================
 
\subsection{Number of series available}

The number of glass eel and glass eel + young yellow eel time-series available
has declined from a peak of
\Sexpr{vv[["nbmaxglasseel"]]} in
\Sexpr{max(as.numeric(vv[["yearmaxglasseel"]]))} to
\Sexpr{vv[["nbcurrentglasseel"]]} in \Sexpr{CY}. The maximum number of older
yellow eel time-series has increased to \Sexpr{vv[["nbmaxyellow"]]} in
\Sexpr{max(as.numeric(vv[["yearmaxyellow"]]))} but dropped to
\Sexpr{vv[["nbcurrentyellow"]]} (Figure \ref{figure2}).

 %========================================== 
\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{figure2.png}
\caption{Trends in number of glass (black circle), glass+young yellow eel
(grey triangle) and older yellow eel (black triangle) time-series giving a
report in  any specific year.}
\label{figure2}
\end{figure}
 %========================================== 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<< generation_of_plot_data, echo=FALSE, eval=TRUE, results=hide >>=
###################################################
# Generation of the dataframes used to plot the data
# two similar dataframe are created
# with the new ggplot2 it is no longer necessary but code was developped earlier at
# the time when such format was still necessary
# we will create a first dataframe (scal) with all the series together, this was
# the initial analysis built by Wgeel, and it is kept for historical consistency
# later on the geomean have been added , and the graph add a bootstrap calculation of the mean (bootscal)
# At some point the wgeel discussed that it might make more sense to separate
# glass eel (scalgeel) and yellow eel (scalyellow), so this graph is showing all, the geomean on all series, the
# trend for glass eel and the trend for yellow eel. This graph shows "unprocessed" data,
# as the wgeel recruitment index uses a glm index to rebuilt a consistent series.
# At some point ACFM asked to use a different scaling period and we complied but the graph
# is no longer shown as it is a bit confusing.
# below now a geom bootstrap is proposed. 
# TODO  2018 discuss whether to present arithmetic (not really good), geometric mean,
# or nothing at all (Willem's suggestion)
###################################################
sgeomean.cl.boot<-function (x, conf.int = 0.95, B = 1000, na.rm = TRUE, reps = FALSE) 
{
  if (na.rm)    x <- x[!is.na(x)]
  n <- length(x)
  # geomean returns a dataframe, convert it to vector
  xbar <- as.numeric(geomean(x))
  if (n < 2L) # 2L is an integer
    return(c(Mean = xbar, Lower = NA, Upper = NA))
  z <- unlist(lapply(seq_len(B), function(i, x, N) sum(x[sample.int(N, 
                        N, TRUE, NULL)]), x = x, N = n))/n
  quant <- quantile(z, c((1 - conf.int)/2, (1 + conf.int)/2))
  names(quant) <- NULL
  res <- c(Geomean = xbar, Lower = quant[1L], Upper = quant[2L])
  if (reps) 
    attr(res, "reps") <- z
  res
}
scal=data.frame("year"=as.numeric(names(tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE))),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"= tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE),
	"ymax"=tapply(wger$value_std_1979_1994,wger$year,max,na.rm=TRUE),
	"mean"=tapply(wger$value_std_1979_1994,wger$year,mean,na.rm=TRUE),
	"geomean"=unlist(tapply(wger$value_std_1979_1994,wger$year,geomean,na.rm=TRUE)))


li_cl_boot=tapply(wger$value_std_1979_1994,wger$year,smean.cl.boot)
li_cl_boot_geomean=tapply(wger$value_std_1979_1994,wger$year,sgeomean.cl.boot)
bootscal=data.frame("year"=as.numeric(names(li_cl_boot)),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
	"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
    "ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
	"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),    
	"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
	"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))
# creating a subset with all data (glass_eel_yoy is limited in its timeframe)
datageel=subset(wger,wger$lifestage!="yellow eel")
scalgeel=data.frame(
	"year"=as.numeric(names(tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE))),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"= tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE),
	"ymax"=	tapply(datageel$value_std_1979_1994,datageel$year,max,na.rm=TRUE),
	"mean"=tapply(datageel$value_std_1979_1994,datageel$year,mean,na.rm=TRUE),
	"geomean"=unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean,na.rm=TRUE))
)
datayellow=subset(wger,wger$lifestage=="yellow eel")
scalyellow=data.frame(
	"year"=as.numeric(names(tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE))),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"= tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE),
	"ymax"=	tapply(datayellow$value_std_1979_1994,datayellow$year,max,na.rm=TRUE),	
	"mean"=tapply(datayellow$value_std_1979_1994,datayellow$year,mean,na.rm=TRUE),
	"geomean"=unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean,na.rm=TRUE)))
scaldata=wger[,c("year","value_std_1979_1994","value_std","site","lifestage")]
################################################################
# With scaling 2000-2010
##############################################################

scal_2000_2009=data.frame("year"=as.numeric(names(tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE))),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"= tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE),
	"ymax"=tapply(wger$value_std_2000_2009,wger$year,max,na.rm=TRUE),  
	"mean"=tapply(wger$value_std_2000_2009,wger$year,mean,na.rm=TRUE),
	"geomean"=unlist(tapply(wger$value_std_2000_2009,wger$year,geomean)))
li_cl_boot=tapply(wger$value_std_2000_2009,wger$year,smean.cl.boot)
bootscal_2000_2009=data.frame("year"=as.numeric(names(li_cl_boot)),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
	"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
    "ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
	"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),
	"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
	"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))

scalgeel_2000_2009=data.frame(
	"year"=as.numeric(names(tapply(datageel$value_std_2000_2009,datageel$year,min))),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"= tapply(datageel$value_std_2000_2009,datageel$year,min,na.rm=TRUE),
	"ymax"=	tapply(datageel$value_std_2000_2009,datageel$year,max,na.rm=TRUE),	
	"mean"=tapply(datageel$value_std_2000_2009,datageel$year,mean,na.rm=TRUE),
	"geomean"=unlist(tapply(datageel$value_std_2000_2009,datageel$year,geomean))
)

scalyellow_2000_2009=data.frame(
	"year"=as.numeric(names(tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE))),
	"value_std"=NA,
	"name"=NA,
	"lifestage"=NA,
	"ymin"= tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE),
	"ymax"=	tapply(datayellow$value_std_2000_2009,datayellow$year,max,na.rm=TRUE),	
	"mean"=tapply(datayellow$value_std_2000_2009,datayellow$year,mean,na.rm=TRUE),
	"geomean"=unlist(tapply(datayellow$value_std_2000_2009,datayellow$year,geomean,na.rm=TRUE)))
scaldata_2000_2009=wger[,c("year","value_std_2000_2009","site","lifestage")]

#########################
# for Miran
# exporting the geomeans 
########################
print("simple geomeans for glass eel, asked by Miran")
round(unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean)),3)
print ("simple geomeans for yellow eels")
round(unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean)),3)

########################################
# FIGURE 3 WITHOUT LOG SCALE
# normalscale + geomean+ bootstrap scaled mean and confidence interval
#########################################

# first option, in the following figure the red line represents the geometric means
# and the dots are the bootstrap means
g<-ggplot(scaldata)
g1<-g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
	geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
	ylab("scaled 1979-1994 values")+
	geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
	geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
	theme(legend.position = "none")

figure3withoutlogscale<-g1+	scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
	scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
x11()
print(figure3withoutlogscale)
dev.off()
save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)

# second option, in the following figure the blue line represents the arithmetic means
# and the dots are the bootstrap geommeans

g<-ggplot(scaldata)
g2<-g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
	geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
	ylab("scaled 1979-1994 values")+
	geom_pointrange(data=bootscal,aes(x=year,y=geomean,ymin=ymin_geomean,ymax=ymax_geomean),size=0.5,colour="black")+
	geom_line(data=scal,aes(x=year,y=mean),colour="#003366",size=1.2)+
	theme(legend.position = "none")

figure3withoutlogscale_opt2<-g2+scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
	scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
x11()
print(figure3withoutlogscale_opt2)
dev.off()
save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)
save_figure("figure3withoutlogscale_opt2",figure3withoutlogscale_opt2,800,600)
# scaldata[scaldata$year>2000&scaldata$value_std>1,]
########################################
# FIGURE 3 WITH LOG SCALE
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

figure3<-g1+
	scale_y_log10(name="scaled 1979-1994 values log scale",limits=c(0.001,30),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
	#ylab()
	
	scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
		minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
	annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)
x11()
print(figure3)
save_figure(figname="figure3",figure3,800,600)


figure3bis<-g1+
	scale_y_log10(name="scaled 1979-1994 values log scale",
        limits=c(0.001,30),
        breaks=c(0.01,0.1,1,10),
        labels=c("1%","10%","100%","1000%"))+
	scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
		minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
	annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)
x11()
print(figure3bis)

save_figure(figname="figure3",figure3,800,600)
save_figure(figname="figure3bis",figure3bis,800,600)

########################################
# FIGURE 3 WITH LOG SCALE {{BLACK}}
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

g<-ggplot(scaldata)
figure3black<-g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5,show.legend=FALSE)+
	geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4,show.legend=FALSE)+
	#ylab("scaled 1979-1994 values")+
	geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
	geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
	scale_y_log10(name="percentage of 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
	scale_x_continuous(breaks=c(1930,1950,1970,1980,1990,2000,2010),
		minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,CY))+
	theme_black()
x11()
print(figure3black)
# {{{{{{{{{{{{{{{{{{{{{{{{{
save_figure(figname="figure3black",figure3black,800,600)

# {{{{{{{{{{{{{{{{{{{{{{{{{
##########################################
## Same graph for presentation but labels are in French
##########################################
#g<-ggplot(scaldata)
#g+geom_point(aes(x=year, y=value_std,colour=site,shape=lifestage),size=1.5,legend=FALSE)+
#		geom_line(aes(x=year, y=value_std,colour=site,lty=lifestage),size=0.4,legend=FALSE)+
#		opts(title="Tendance du recrutement Europeen")+
#		#ylab("scaled 1979-1994 values")+
#		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
#		scale_y_log10(name="% de 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
#		scale_x_continuous(name="Annee",breaks=c(1930,1950,1970,1980,1990,2000,2010),
#				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,2010))+theme_dark()
########################################
# FIGURE 4 
# limited graph with scale
########################################
scallog<-scal
scallog[scallog$ymin<1e-2,"ymin"]<-1e-2
scallog[scallog$ymax>30,"ymax"]<-30
g<-ggplot(scallog)
figure4<-g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey",data=scallog)+
	ylab("scaled 1979-1994 values log scale")+
	geom_line(aes(x=year,y=mean),data=scalgeel,colour="darkblue",size=1)+
	geom_line(aes(x=year,y=mean),data=scalyellow,colour="darkorange4",size = 1)+
	geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
	scale_y_log10(limits=c(0.01,30),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+
	annotate("rect",xmin=1930,ymin=0.01,xmax=1960,ymax=30,fill="white",alpha=0.7)+
	scale_x_continuous(limits=c(1930,CY))
x11()
print(figure4)
save_figure(figname="figure4",figure4,800,600)

########################################
# FIGURE 4 
# BUT WITH REFERENCE 2000-2010 !
########################################
scallog<-scal_2000_2009
scallog[scallog$ymin<1e-1,"ymin"]<-1e-1
scallog[scallog$ymax>1000,"ymax"]<-1000
g<-ggplot(scallog)
figure42000_2009<-g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey")+
	#ggtitle("Recruitment European overview")+
	ylab("scaled to 2000-2010, log scale")+
	geom_line(aes(x=year,y=mean),data=scalgeel_2000_2009,colour="darkblue",size=1)+
	geom_line(aes(x=year,y=mean),data=scalyellow_2000_2009,colour="darkorange4",size = 1)+
	geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
	geom_abline( intercept = 0,slope=0,	alpha = .4,col="red")+
	geom_abline( intercept = 2,slope=0,	alpha = .4,col="red")+
	scale_y_log10(limits=c(1e-1,1000),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+		
	scale_x_continuous(limits=c(1930,CY))+
	annotate("rect",xmin=1930,ymin=1e-1,xmax=1960,ymax=1000,fill="white",alpha=0.7)+
	annotate("rect", xmin = 2000, xmax = 2009, ymin = 0.3, ymax = 3,
		alpha = .2,fill="blue")

x11()
print(figure42000_2009)

save_figure(figname="figure4_2000_2009",figure42000_2009,800,600)

########################################
# FIGURE NOTHING 
# JUST TO CHECK 
########################################
x11()
xg<-unlist(tapply(datageel$value_std,datageel$year,geomean))
rxg<-as.numeric(names(xg))
xy<-unlist(tapply(datayellow$value_std,datayellow$year,geomean))
rxy<-as.numeric(names(xy))
plot(rxg,
	xg,
	type="b",
	main="a simple graph to check that ggplot's running fine")
points(rxy,xy,type="l",col="green")
legend("topright",legend=c("glass","yellow"),col=c("black","green"),lty=1)

# additional figure to check log scaled
x11()
plot(rxy,
	xy,log="y",
	type="b",col="green")
points(rxg,xg,type="l")
#tapply(wger$value_std,wger$year,mean_cl_boot)


########################################
# Figure to put forward recent changes in the series
# WITH REFERENCE 2000-2010 !
########################################
figure_check_one_series<-function(site='Katw',limits=c(1900,CY)){
  g<-ggplot(scaldata_2000_2009)
  g<-g+geom_point(aes(x=year, y=value_std_2000_2009),col="grey",size=1.5)+
	  geom_line(aes(x=year, y=value_std_2000_2009),col="grey",size=0.4)+
	  geom_point(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
	  geom_line(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
	  ylab("scaled 1979-1994 values")+
	  geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
	  geom_line(data=scal_2000_2009,aes(x=year,y=geomean),colour="red",size=1.2)+
	  theme(legend.position = "none")+
	  scale_x_continuous(limits=limits,breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata_2000_2009$year),to=max(scaldata_2000_2009$year),by=2))+
	  scale_y_continuous(limits=c(0,20))+
	  annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
  return(g)
}
figure_check_one_series("Katw",limits=c(1960,2019))
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<< model_for_glass_eel_and_yellow_eel, echo=FALSE, eval=TRUE, results=hide >>=

glass_eel_yoy$site<-as.factor(glass_eel_yoy$site)

model_ge_area=glm(value_std~year_f:area+site,
	data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
	family=Gamma(link=log), maxit=300)
print("Analysis for glass eel")
print("data available")
(area_year=table(glass_eel_yoy$year,glass_eel_yoy$area))
print("number of sites finally selected for glass eel glm")
vv$modelge<-list()
vv$modelge$site<-as.character(model_ge_area$xlevels$site)
vv$modelge$nbsite<-length(vv$modelge$site)
vv$modelge$excluded<-unique(glass_eel_yoy$site)[!unique(glass_eel_yoy$site)%in%vv$modelge$site]
vv$modelge$value_excluded_zero<-glass_eel_yoy[glass_eel_yoy$value==0&!is.na(glass_eel_yoy$value),
	c("value_std","site","year","lifestage","das_comment","area")]

model_older=glm(value_std~year_f+as.factor(site),data=older,family=Gamma(link=log),
	subset=older$value>0 & older$year>1949  ,maxit=300)
vv$modelolder<-list()
vv$modelolder$site<-as.numeric(as.character(model_older$xlevels$`as.factor(site)`))
vv$modelolder$nbsite<-length(vv$modelolder$site)
vv$modelolder$excluded<-unique(older$site)[!unique(older$site)%in%vv$modelolder$site]
vv$modelolder$excludedsite<-unique(older[older$site%in%vv$modelolder$excluded,"site"])
vv$modelolder$excludedsite<-unique(older[older$site%in%vv$modelolder$excluded,"site"])
vv$modelolder$value_excluded_zero<-older[older$value==0,
	c("value_std","site","year","lifestage","das_comment","area")]

xt_a<-xtable(Anova(model_ge_area,test="F"),
	caption=c("Anova for glass eel recruitment model",
		label="table_anova"))

o<-print(xt_a, file = str_c(tabwd,"/table_anova.tex"), 
	table.placement = "htbp",
	caption.placement = "top",
	NA.string = "",
	include.rownames=TRUE,
	tabular.environment="tabularx",
	width="0.8\\textwidth",
	sanitize.colnames.function=function(x){x})	
save(model_ge_area,model_older,file=paste0(shinywd,"recruitment_models.Rdata"))
#plot(model_ge_area)
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


<< model_for_glass_eel_graph_and_predictions, echo=FALSE, eval=TRUE, results=hide >>=
# 1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~
######################################"
#~glass eel (and elver = glass eel + yellow eel) migrant analysis
######################################"~
# 1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~~
# using expand.grid to build a complete grid for predictions
data_bis=expand.grid(year_f=model_ge_area$xlevels$year_f,area=model_ge_area$xlevels$area,
	site=model_ge_area$xlevels$site)
data_bis$year<-as.numeric(as.character(data_bis$year_f))
#deleting area/year not avalaible
for(area in as.character(unique(glass_eel_yoy$area))){
  data_bis[data_bis$area==area,"nb_site"]=
	  area_year[as.character(data_bis[data_bis$area==area,"year"]),area]
}
data_bis=data_bis[data_bis$nb_site>0,]


#predicting
data_bis$p=predict(model_ge_area,newdata=data_bis[,],type="response")
se=predict(model_ge_area,newdata=data_bis[,],type="response",se.fit=TRUE)
data_bis$se=se[["se.fit"]]

# 2 options mean or geomean

# Calculate mean or geomean, per series EE or NS for the ref period 1960 1980 ------------------------------------------
#standardising prediction to 1960-1980 level

if (opt_calculation=="geomean") {
  mean_1960_1979=data.frame(mean=unlist(
		  tapply(data_bis[data_bis$year>=1960 & data_bis$year<1980,"p"],
			  data_bis[data_bis$year>=1960 & data_bis$year<1980,"area"],
			  geomean)
	  ))
} else {
  mean_1960_1979=data.frame(mean=unlist(
		  tapply(data_bis[data_bis$year>=1960 & data_bis$year<1980,"p"],
			  data_bis[data_bis$year>=1960 & data_bis$year<1980,"area"],
			  mean)
	  ))
}
mean_1960_1979$area=rownames(mean_1960_1979)
data_bis=merge(data_bis,mean_1960_1979,by="area")
data_bis$p_std_1960_1979=data_bis$p/data_bis$mean

# A tapply to calculate either geom mean or mean of series ------------------------------------------

# cannot show any se on average value, se is on each individual value !
#data_bis$se_std_1960_1979=data_bis$se/data_bis$geomean 
#data_bis$ymin<-data_bis$p_std_1960_1979-data_bis$se_std_1960_1979
#data_bis$ymax<-data_bis$p_std_1960_1979+data_bis$se_std_1960_1979
# geomean does not return a "nice" numeric, hence the trick below
if (opt_calculation=="geomean") {
  synthesis=as.data.frame(tapply(data_bis[,"p_std_1960_1979"],
		  list(data_bis[,"year_f"],data_bis[,"area"]),
		  function(X) {Y=geomean(X) ;
			return(as.numeric(Y))}))
} else {
  synthesis=as.data.frame(tapply(data_bis[,"p_std_1960_1979"],
		  list(data_bis[,"year_f"],data_bis[,"area"]),mean,na.rm=TRUE))
}

# Save data_bis as glass_eel_pred for shiny ----------------------------------------------
glass_eel_pred <- data_bis
save(glass_eel_pred,file=str_c(datawd,"glass_eel_pred.Rdata"))
save(glass_eel_pred,file=str_c(shinywd,"glass_eel_pred.Rdata"))
resy=function(data,valcol){
  data$time=rownames(data)
  data1=melt(data,id.vars=ncol(data))
  colnames(data1)=c("year","area",valcol)
  data1$year=as.Date(strptime(paste(data1$year,"-01-01",sep=""),format="%Y-%m-%d"))
  return(data1)
}
dat=resy(synthesis,"p_std_1960_1979")


##plotting
#with(synthesis,matplot(time,log(synthesis[,-dim(synthesis)[2]]),type="l"))
#legend("topright",legend=names(synthesis)[-dim(synthesis)[2]],lty=1:5,col=1:6)
#abline(v=seq(1950,2005,5),lty=2,col="gray")
#abline(v=seq(1950,2005,10))

#tat_sum_single <- function(fun, geom="point", ...) { 
#   stat_summary(fun.y=fun, colour="red", geom=geom, size = 3, ...) 
# } 
# 

g<-ggplot(dat,aes(x=year,y=p_std_1960_1979))

figure5_without_logscale<-g+geom_line(aes(colour=area,lty=area),lwd=1)+ 
	scale_colour_brewer(name="area",palette="Set1")+
	scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
	theme_bw()+
	geom_hline(yintercept=1,linetype=2)+
	theme(legend.box =NULL,
		legend.key = element_rect(colour = NA, fill = 'white'),
		legend.text = element_text(size = 10, colour = 'black'), 
		legend.background = element_rect(colour = NA, fill = 'white'),
		legend.position = c(.8, .8))
X11(300,250)
figure5_without_logscale
save_figure("figure5_without_logscale",figure5_without_logscale,600,480)

# function similar to theme_dark() but allows legends
# black and white plot ====
figure5_without_logscale_black<-g+geom_line(aes(colour=area,lty=area),lwd=1)+
	scale_colour_manual(name="area",values=c("yellow","lawngreen"))+
	scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
	theme_black()

X11()
figure5_without_logscale_black
save_figure("figure5_without_logscale_black",figure5_without_logscale_black,600,480)


#====
#+geom_smooth(aes(ymin = min, ymax = max,fill=area),stat="identity")+facet_grid( ~ area) 
datEE<-dat[dat$area=="Elsewhere Europe",]
datNS<-dat[dat$area=="North Sea",]
labelEE<-100*round(datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],3)
labelNS<-100*round(datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],3)

figure5<-g+geom_line(aes(colour=area,lty=area),lwd=1.3)+geom_point(aes(colour=area,fill=area,shape=area),size=3)+
	#ggtitle("Recruitment overview glass eel series")+
	scale_colour_brewer(name="area",palette="Set1")  +
	#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
	#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
	scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
		#limits=c(0.005,10),
		breaks=c(0.01,0.1,1,10),
		labels=c("1%","10%","100%","1000%"))+
	theme_bw()+
	theme(legend.box =NULL,
		legend.key = element_rect(colour = NA, fill = 'white'),
		legend.text = element_text(size = 10, colour = 'black'), 
		legend.background = element_rect(colour = NA, fill = 'white'),
		legend.position=c(.8,.9))

X11()
figure5
save_figure("figure5",figure5,600,480)
#figure5danish<-g+geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		ggtitle("title="Glasaal data fra hele Europa")+
#		scale_colour_brewer(name="area",palette="Set1")  +
#		xlab("Aar")+
#		scale_y_log10(name="Linear model forudsigelser/ gennemsnit 1960-1979",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#figure5danish

#levels(dat$area)<-c (
#		iconv("Andre steder i Europa","UTF8"),
#		iconv("Nordsjøen","UTF8"))#
#g<-ggplot(dat,aes(x=year,y=p_std_1960_1979))
#figure5norvegiean<-g+
#		geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,shape=area),size=3)+
#		ggtitle(label=iconv("Indeks av glassålrekruttering","UTF8"))+
#		scale_colour_brewer(name=iconv("Området","UTF8"),palette="Set1")  +
#		scale_shape(name=iconv("Området","UTF8"))+
#		scale_linetype(name=iconv("Området","UTF8"))+
#		xlab(iconv("År","UTF8"))+
#		scale_y_log10(name=iconv("Standardiserte GLM-prognoser (i prosent av
#		1960-1979-gjennomsnitt)","UTF8"), #limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#save_figure("figure5norvegiean",figure5norvegiean,600,480)
#pdf("images/2013/figure5norvegiean.png")
#figure5norvegiean
#dev.off()
save_figure("figure5",figure5,600,480)
#save_figure("figure5danish",figure5danish,600,480)

#figure5danish<-g+geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		ggtitle("title="Glasaal data fra hele Europa")+
#		scale_colour_brewer(name="area",palette="Set1")  +
#		xlab("Aar")+
#		scale_y_log10(name="Linear model forudsigelser/ gennemsnit 1960-1979",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
levels(dat$area)=c("EE","NS")
g<-ggplot(dat,aes(x=year,y=p_std_1960_1979))

#figure5bw<-g+geom_line(aes(colour=area,lty=area),wd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		#ggtitle("Recruitment overview glass eel series")+
#		scale_colour_manual(name="area",values=c("black","grey40"))  +
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
#		scale_y_log10(name="standardized glm predictions \n mean 1960-1979-log scale",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))+
#		theme_bw()+
#		theme(legend.box =NULL,
#				legend.key = element_rect(colour = NA, fill = 'white'),
#				legend.text = element_text(size = 8, colour = 'black'), 
#				legend.background = element_rect(colour = NA, fill = 'white'))
#print(figure5bw)
#save_figure("figure5bw",figure5bw,600,480)

synthesis$year=as.numeric(rownames(synthesis))
synthesis$decade=trunc(as.numeric(synthesis$year)/5)*5
five_year_avg_glass<-data.frame("Elsewhere Europe"=tapply(synthesis$"Elsewhere Europe",synthesis$decade,mean,na.rm=T),
	"North Sea"=tapply(synthesis$"North Sea",synthesis$decade,mean,na.rm=T))
synthesis$rebour<-nrow(synthesis):1
last<-synthesis$rebour<=5
five_year_avg_glass<-rbind(five_year_avg_glass,apply(synthesis[last,c("Elsewhere Europe","North Sea") ],2,mean))
rownames(five_year_avg_glass)[nrow(five_year_avg_glass)]<-"last"

#xfive_year_avg_glass <- xtable(x = five_year_avg_glass,
#		label = "table_five_year_avg_glass",
#		caption = str_c("GLM estimates for glass eel series, averaged every five years"))
#print(xfive_year_avg_glass, 
#		file = str_c(tabwd,"/table_five_year_avg_glass.tex"),
#		table.placement = "htbp",
#		caption.placement = "top", 
#		NA.string = ".")
gg0<-synthesis[as.character(1960:CY),c("Elsewhere Europe","North Sea")]
colnames(gg0)<-c("EE","NS")

gg<-split_per_decade_ge(gg0)
gg[,1:8]<-100*round(gg[,1:8],2)
gg[,9:ncol(gg)]<-100*round(gg[,9:ncol(gg)],3)
nothing<-latex(gg,
	rowlabel="",
	rowlabel.just="c",
	where="hptb",
	cgroup=cgroupdecade,
	n.cgroup=rep(ncol(gg0),length(cgroupdecade)),
	collabel.just=strsplit("c c c c c c c c c c c c c c c", " ")[[1]],	
	col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
	#landscape=TRUE,
	label="table_glm_glass_eel",
	caption=str_c("GLM $glass~eel \\sim year:area + site $ geometric means of predicted values for ",vv$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period."),	
	file= str_c(tabwd,"/table_glm_glass_eel.tex"))


#decades results
decA<-tapply(synthesis$"North Sea",synthesis$decade,mean,na.rm=T)
decE<-tapply(synthesis$"Elsewhere Europe",synthesis$decade,mean,na.rm=T)
#decA[(length(decA)-1):length(decA)]
#decE[(length(decE)-1):length(decE)]



write.table(synthesis,file=str_c(datawd,"glm_results_glass.csv"),sep=";")

#plot(log(synthesis[synthesis$year>1979,"Elsewhere Europe"]))
trend<-synthesis[synthesis$year>1979,]
trend$EE<-trend$"Elsewhere Europe"
trend$lEE<-log(trend$EE)

trend$lNS<-log(trend$"North Sea")
#round(lm(lEE~year,data=trend)$coefficient[2],4) # -0.098
#round(lm(lNS~year,data=trend)$coefficient[2],4) # -0.098 North Sea -0129

# sgipee test for change ee ---------------------------------------------

#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
#sgipee_test_for_change_ee<-summary(test1)$coefficients[3,4]
#if (sgipee_test_for_change_ee<=0.05) {
#  test_sgipee_char_ee<-"significant"
#}else {
#  test_sgipee_char_ee<-"not significant"
#}

## test on the trend after 2011 ee ----------------------------------------------
#
#K = matrix(c(0,1,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
#summary_coefficient_after <- summary(glht(test1, linfct = K, alternative="greater"))
#confint_coefficient_after <-confint(glht(test1, linfct = K, alternative="greater"))
#trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)


# sgipee test for change ns ---------------------------------------------

#test=lm(lNS~year+pmax(year,2011),data=trend)
#
#sgipee_test_for_change_ns<-summary(test)$coefficients[3,4]
#if (sgipee_test_for_change_ns<=0.05) {
#  test_sgipee_char_ns<-"significant"
#}else {
#  test_sgipee_char_ns<-"not significant"
#}

## test on the trend after 2011 ns ----------------------------------------------
#
#
#summary_coefficient_after <- summary(glht(test, linfct = K, alternative="greater"))
#confint_coefficient_after <-confint(glht(test, linfct = K, alternative="greater"))
#trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)


# test glm with a breakpoint ----------------------------------------------------
# this models takes numeric, not factors we assume a log trend
model_ge_area_b=glm(value_std~year:area+site+pmax(year,2011):area,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>=1980,],
		family=Gamma(link=log), maxit=300)
#summary(model_ge_area_b)
# plot(model_ge_area_b)
len<- length(coef(model_ge_area_b))
gg<-visreg::visreg(model_ge_area_b,"year",by="area", plot=TRUE,gg=TRUE,band=FALSE)
gg <- gg+facet_wrap(~area,scales="free_y")
print(gg)
# last coeff are
# year:areaElsewhere Europe 
# year:areaNorth Sea 
# areaElsewhere Europe:pmax(year, 2011)   
# areaNorth Sea:pmax(year, 2011) 
#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
# this is the n-1 row of the summary
sgipee_test_for_change_ee<-summary(model_ge_area_b)$coefficients[len-1,4]   
sgipee_test_for_change_ns<-summary(model_ge_area_b)$coefficients[len,4]

Kee = matrix(c(rep(0,len-4),1,0,1,0), nrow = 1) # we just add the to coef trend to have the trend after 2011
summary_coefficient_afteree <- summary(glht(model_ge_area_b, linfct = Kee, alternative="greater",rhs=0.05))
Kns = matrix(c(rep(0,len-4),0,1,0,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
summary_coefficient_afterns <- summary(glht(model_ge_area_b, linfct = Kns, alternative="greater"))
trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afteree$test$coefficients,
		summary_coefficient_afteree$test$pvalues)
trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afterns$test$coefficients,
		summary_coefficient_afterns$test$pvalues)
save(dat, file=str_c(datawd,"dat_ge.Rdata"))
save(dat, file=str_c(shinywd,"dat_ge.Rdata"))
@
<< model_diagnostics, echo=FALSE, eval=FALSE, results=hide >>=
# summary(model_ge_area)
# influence_plot
require(boot)
gey<-glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959&!is.na(glass_eel_yoy$value_std),]
gey$E<-resid(model_ge_area) # working residuals
gey$P=predict(model_ge_area)
plot(coefficients(model_ge_area)[grep("North Sea",names(coefficients(model_ge_area)))],type="l")
points(log(datNS$p_std_1960_1979)+4,type="l",col="red")
plot(gey$E~gey$P)

# Three ways of getting the diagnostic graph of residuals
glm.diag.plots(model_ge_area)
plot(model_ge_area,which=1)
panel.smooth(gey$P,gey$E,col="black",col.smooth="red")
library(lattice)
panel.smoother <- function(x, y) {
  panel.xyplot(x, y) # show points 
  panel.loess(x, y,col.line="red")  # show smoothed line 
  panel.abline(h=0)
}
panel.smoother2 <- function(x, y) {
  panel.xyplot(x, y) # show points 
  panel.loess(x, y,col.line="red")  # show smoothed line 
  panel.abline(h=-0.2)
}
mga_diag<-glm.diag(model_ge_area)
gey$res<-mga_diag$res
show.settings()

xyplot(res~P, data=gey,scales=list(cex=.8, col="black"),
	panel=panel.smoother,
	xlab="Predicted", ylab="residuals", 
	main="Jacknife deviance residuals agains the fitted value")
xyplot(res~year, data=gey,scales=list(cex=.8, col="black"),
	panel=panel.smoother2,
	xlab="Predicted", ylab="residuals", 
	main="Jacknife deviance residuals agains the fitted value")
abline(h=0)
xyplot(res~P|area, data=gey,scales=list(cex=.8, col="black"),
	panel=panel.smoother,
	xlab="Predicted", ylab="residuals", 
	main="Jacknife deviance residuals agains the fitted value")
xyplot(res~P|site, data=gey,scales=list(cex=.8, col="black"),
	panel=panel.smoother,
	xlab="Predicted", ylab="residuals", 
	main="Jacknife deviance residuals agains the fitted value")
# un résidu / carte par annee


# pour aller chercher les stations en 3035
locxy_3035<-sqldf("select ser_id,st_x(the_geom) as X, st_y(the_geom) as Y from ts.t_location_loc where loc_tyl_code='Recruit'")
gey<-merge(gey,locxy_3035,by="ser_id",all.x=TRUE,all.y=FALSE)
Gey<-gey #spatial data frame
coordinates(Gey)<-c("x","y")
# dev.size("px") to check right dimensions
#png(file=str_c(imgwd,"/resid_bretagne.png"), width=672,height= 389)

#bb<-elargit(bb,0.01,0.01)

#frequire(latticeExtra) # a + as.layer(b) pour mettre deux graphiques
# but for now I don't have missing data there
emu_c=readShapePoints(str_c(shpwd,"/","t_emuagreg_ema_point_3035.shp")) # a spatial object of class sp
# this corresponds to the center of each emu.
wisesp=readShapePoly(str_c(shpwd,"/","rbd_f1v3_3035.shp")) # a spatial object of class sp
# this is the map showing the "missing parts", to be placed behind the others
country_c=readShapePoints(str_c(shpwd,"/","t_country_coun_3035"))# a spatial object of class sp
# this is the map of coutry centers, to overlay points for each country
emusp0=readShapePoly(str_c(shpwd,"/","t_emuagreg_ema_3035")) # a spatial object of class sp
years<-1960:2019
bb<-bbox(emusp0)
# loop to create all the graphs
for (year in years){
  #trellis.device(device="png",filename=str_c(imgwd,"/resids/",year,".png"))
  png(filename=str_c(imgwd,"/resids/",year,".png"),width=600, height=500)
  bb<-bubble(Gey[Gey@data$year==year,], "E",col=c("red","green"),main=str_c(year),
	  xlab="",ylab="",
	  do.sqrt = FALSE,
	  sp.layout=list("sp.polygons", emusp0,    first = FALSE)
  ) 		
  print(bb)
  dev.off()
}
# 
model_ge_area<-gls(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
	subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959 ,maxit=300)

lmer(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
	subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959)

#library(nlme)
glass_eel_yoy$lvalue_std=log(glass_eel_yoy$value_std)
M.lm <- gls(lvalue_std~site,data=glass_eel_yoy)

vf1Fixed <- 
	
	M.gls1 <-glmmPQL(value_std~year_f:area+site,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		random = ~ 1 | site,
		weights = varIdent (form = ~ 1 | site) ,
		family=Gamma(link=log)
	)
M.gls1 <-glmmPQL(value_std~year_f:area+site,
	data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
	random = ~ 1 | site,
	family=Gamma(link=log)
)
# prediction for lough neagh
# historical data
#glass_eel_yoy2=wger[wger$lifestage!="yellow eel" ,] #glass eel and yoy
#model_ge_area2=glm(value_std~year_f:area+site,data=glass_eel_yoy2[glass_eel_yoy2$value>0 ,],
#	family=Gamma(link=log), maxit=300)
#
#newdata<-expand.grid(year_f=levels(glass_eel_yoy2$year_f),site="Bann",area="Elsewhere Europe")
#newdata<-newdata[as.numeric(as.character(newdata$year_f))>1922,]
#newdata$P=predict(model_ge_area2,type="response",newdata=newdata)
#newdata$year<-as.numeric(as.character(newdata$year_f))
#
#plot(newdata$year,newdata$P, type="b",col="black",xlab="year",ylab="standardized value")
#gey2<-glass_eel_yoy2[glass_eel_yoy2$site=='Bann',]
#gey2<-gey2[order(gey2$year),]
#points(gey2$year,gey2$value_std, type="b",col="grey40",lty=2,pch=18)
#legend("topright",col=c("black","grey20"),lty=c(1,2),pch=c(1,18),legend=c("predicted for Bann","Bann (observed)"))
#write.table(gey2,file=str_c(datawd,"Bann_data.csv"),sep=";")
#write.table(newdata,file=str_c(datawd,"Bann_predictions.csv"),sep=";")
@

<< model_for_yellow_eel, echo=FALSE, eval=TRUE, results=hide >>=
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~
######################################"
#~yellow eel migrant analysis
######################################"~
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~~

print("Analysis for yellow eel")
area_year_older=table(older$year,older$area)
vv$nb_for_yellow_eel_glm<-length(unique(older$site))
table(older$geo)
print("stations selected for analysis")
unique(older$site)
model_older=glm(value_std ~ year_f + as.factor(site),
	data = older,
	family = Gamma(link=log),
	subset = older$value >0 &
		older$year > 1949,
	maxit = 300)
# parteen was removed but is no longer among the series
summary(model_older)
#plot(model_older)
anova(model_older,test="F")

data_bis=expand.grid(year_f=unique(model_older$xlevels$year_f),
	site=model_older$xlevels$`as.factor(site`)
data_bis$year=as.numeric(as.character(data_bis$year))

#predicting --------------------------------------------------------------------------------------------

data_bis$p=predict(model_older,newdata=data_bis,type="response")

#standardising prediction to 1960-1979 level -----------------------------------------------------------
# 2 options mean or geomean

if (opt_calculation=="geomean") {
  data_bis$mean_1960_1979=as.numeric(geomean(data_bis[data_bis$year>=1960 & data_bis$year<1980,"p"]))
} else {
  data_bis$mean_1960_1979=mean(data_bis[data_bis$year>=1960 & data_bis$year<1980,"p"])
}
data_bis$p_std_1960_1979=data_bis$p/data_bis$mean_1960_1979

# saving yellow_eel_pred for shiny ---------------------------------------------------------------------

yellow_eel_pred <- data_bis
save(yellow_eel_pred,file=paste0(datawd,"yellow_eel_pred.Rdata"))
save(yellow_eel_pred,file=paste0(shinywd,"yellow_eel_pred.Rdata"))
# the trend is the mean or geomean (now geomean see init) of all series --------------------------------

if (opt_calculation=="geomean") {
  dat_ye=data.frame("yellow_eel"=
          unlist(tapply(data_bis[,"p_std_1960_1979"],list(data_bis[,"year_f"]),geomean)))
} else {
  dat_ye=data.frame("yellow_eel"=
          unlist(tapply(data_bis[,"p_std_1960_1979"],list(data_bis[,"year_f"]),mean)))
}

dat_ye$time=rownames(dat_ye)
dat_ye$decade=trunc(as.numeric(dat_ye$time)/5)*5
if (opt_calculation=="geomean") {
  five_year_avg_yellow<-data.frame("yellow_eel"=tapply(
		  dat_ye$"yellow_eel",dat_ye$decade,
		  function(X){Y=geomean(X) ;return(as.numeric(Y))}))
}else{
  five_year_avg_yellow<-data.frame("yellow_eel"=tapply(
		  dat_ye$"yellow_eel",dat_ye$decade,
		  mean,na.rm=T))
}
dat_ye$rebour<-nrow(dat_ye):1
rownames(five_year_avg_yellow)[nrow(five_year_avg_yellow)]<-"last"

(decY<-tapply(dat_ye$"yellow_eel",dat_ye$decade,mean,na.rm=T))
dat_ye$rebour<-nrow(dat_ye):1
last<-dat_ye$rebour<=5
mean(dat_ye[last,c("yellow_eel") ],na.rm=TRUE)
rownames(dat_ye)<-dat_ye$time

#xfive_year_avg_yellow <- xtable(x = five_year_avg_yellow, 
#		label = "table_five_year_avg_yellow",
#		caption = str_c("GLM estimates for glass eel series, averaged every five years"))
#print(xfive_year_avg_yellow,
#		file = str_c(tabwd,"/table_five_year_avg_yellow.tex"),
#		table.placement = "htbp",
#		caption.placement = "top",
#		NA.string = ".")

# Table --------------------------------------------------------------------------------------------

yy0<-dat_ye[,"yellow_eel",drop = FALSE]


yy<-split_per_decade(data=yy0)
yy<-100*round(yy,2)
nothing<-latex(yy,
	rowlabel="",
	rowlabel.just="c",
	where="hptb",
	col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
	landscape=FALSE,
	label="table_glm_yellow",
	caption=str_c("GLM $yellow~eel \\sim year + site $ geometric means of predicted values for ",vv$nb_series_older, " yellow eel series, values given in percentage of the 1960-1979 period."),	
	file= str_c(tabwd,"/table_glm_yellow.tex"))

# Figures -------------------------------------------------------------------------------------------

dat_ye$year <- dat_ye$time
dat_ye$time =as.Date(strptime(paste(dat_ye$time,"-01-01",sep=""),format="%Y-%m-%d"))
g<-ggplot(dat_ye,aes(x=time,y=yellow_eel)) 
figure6_without_log_scale<-g+geom_line(lwd=1)+ geom_point()+
	scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
	theme_bw()+
	geom_hline(yintercept=1,linetype=2)+
    xlab("year")+
	theme(legend.box =NULL,
		legend.key = element_rect(colour = NA, fill = 'white'),
		legend.text = element_text(size = 8, colour = 'black'), 
		legend.background = element_rect(colour = NA, fill = 'white'))#+
#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="grey20")
save_figure("figure6_without_log_scale",figure6_without_log_scale,600,480)
figure6_without_log_scale
figure6_without_log_scale_black<-g+geom_line(lwd=1,color="white")+ 
    geom_point(color="white")+
	scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
	#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="turquoise1") +
	theme_black()
figure6_without_log_scale_black
save_figure("figure6_without_log_scale_black",figure6_without_log_scale_black,600,480)
figure6<-g+geom_line(lwd=1)+geom_point()+
	scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' (log scale)'),
		#limits=c(0.005,10),
		breaks=c(0.01,0.1,1,10),
		labels=c("1%","10%","100%","1000%")) +
    xlab("year")+
	theme_bw()+
	theme(legend.box =NULL,
		legend.key = element_rect(colour = NA, fill = 'white'),
		legend.text = element_text(size = 8, colour = 'black'), 
		legend.background = element_rect(colour = NA, fill = 'white'))
#stat_smooth(method="lm",formula=y ~ ns(x,4), lty=2, size=0.8,alpha=0.3,col="grey20")
figure6
save_figure("figure6",figure6,600,480)

# Final save ----------------------------------------------------------------------------------------

write.table(synthesis,file=str_c(datawd,"glm_results_yellow.csv"),sep=";")
dat_ye <- dat_ye[,c("year","yellow_eel")]
colnames(dat_ye) <-c("year","geomean_p_std_1960_1979") 
save(dat_ye,file=paste0(datawd,"dat_ye.Rdata")) 
save(dat_ye,file=paste0(shinywd,"dat_ye.Rdata")) 
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Check on series updates for the 2019 analyses}

\Sexpr{sn(vv[["nCY"]])} time-series were updated to \Sexpr{CY} (
\Sexpr{sn(vv[["nCYG"]])} for glass eel, \Sexpr{sn(vv[["nCYGY"]])} for
glass + yellow eel and \Sexpr{sn(vv[["nCYY"]])} for yellow eel  (Table
\ref{table_seriesCY})).
\Sexpr{sn(vv[["nCYm1"]])} time-series (\Sexpr{sn(vv[["nCYm1G"]])} for glass eel,
\Sexpr{sn(vv[["nCYm1GY"]])} for glass + yellow eel and
\Sexpr{sn(vv[["nCYm1Y"]])} for yellow eel) were updated to \Sexpr{CY-1}
only (Table \ref{table_seriesCYm1})).  

\Sexpr{sn(vv[["nseries_lost"]])} time-series have been stopped or not updated
beyond 2016 (\Sexpr{sn(vv[["nseries_lostG"]])} for glass eel,
\Sexpr{sn(vv[["nseries_lostGY"]])} for glass eel + yellow eel and
\Sexpr{sn(vv[["nseries_lostY"]])} for yellow eel (Table
\ref{table_serieslost})) but are still included in the analysis.
Some have stopped reporting either because of a lack of recruits in the case of
the fishery-based surveys (Ems in Germany, stopped in 2001; Vidaa in Denmark, stopped in 1990),
 a lack of financial support (the Tiber in Italy, 2006) or the introduction of
quota from from 2008 to 2011 that has disrupted the five fishery-based French
time-series . The two English series (FlaE and BeeG) are still operating but
data have not been updated since 2016.


 %====================================
	\input{\Sexpr{str_c(tabwd,"/table_seriesCY.tex")}}
 %====================================

 %====================================
	\input{\Sexpr{str_c(tabwd,"/table_seriesCYm1.tex")}}
 %====================================

 %====================================
	\input{\Sexpr{str_c(tabwd,"/table_serieslost.tex")}}
 %====================================


\setlength{\tabcolsep}{4pt} % defaut 6pt (table column separator)

\subsection{Raw data}
 
Calculation of the geometric mean of all time-series \footnote{This figure is given as it
consistent with the trend provided by WGEEL from 2002 to 2006. The scaling is
performed on the 1979-1994 average of each time-series, and \Sexpr{length(vv[["sc_1979_1994_unused_series"]])} time-series without data during that
period are excluded from the analysis. The time-series left out are :
\Sexpr{paste(vv[["sc_1979_1994_unused_series"]],collapse=", ")}}. \\
 is given in (Figures
\ref{figure3} and \ref{figure4}). 

%==========================================
\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\textwidth]{figure3.png}
\caption{Time-series of glass eel and yellow eel recruitment in European rivers
with time-series having data for the 1979-1994 period
(\Sexpr{vv[["sc_1979_1994_nb"]]} sites).
Each time-series has been scaled to its 1979-1994 average. Note the logarithmic scale
on the y-axis. The mean values and their bootstrap confidence interval (95\%) are represented as
black dots and bars. Geometric means are presented in red.}
\label{figure3}
\end{figure}

%==========================================
\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\textwidth]{figure4.png}
\caption{Time-series of glass eel and yellow eel recruitment in Europe
with \Sexpr{vv[["sc_1979_1994_nb"]]} time-series out of the \Sexpr{vv[["nb_series_init"]]}
available to the working group. Each time-series has been scaled to its 1979-1994 average. 
The mean values of combined yellow and glass eel time-series and their bootstrap 
confidence interval (95\%) are represented as black dots and bars.
 The brown line represents the mean value for yellow eel, the blue line represents the mean value for glass eel time-series.
 The range of  these  time-series  is  indicated  by  a  grey  shade.  Note that
 individual time-series  from  Figure \ref{figure3}  were  removed to make the
 mean value more clear.  Note also the logarithmic scale on the y-axis.}
\label{figure4}
\end{figure}
%==========================================


\subsection{GLM based trend}

The WGEEL recruitment index used in the ICES Annual Stock Advice is a
reconstructed prediction using a GLM (Generalised Linear Model) with gamma distribution and a log link:
$glass~eel \sim year:area + site $, where $glass~eel$ is individual glass eel
time-series, including both pure G series and those identified as a mixture of
glass and yel-low eel (G+Y), $site$ is the site monitored for recruitment,
area is either the continental North Sea or Elsewhere Europe, and year is the
year coded as a categorical value.
For yellow eel time-series, only one estimate is provided:
$yellow~eel \sim year + site $. 

The trend is reconstructed using the predictions from 1960 onwards for
\Sexpr{vv$modelge$nbsite} glass eel time-series and from 1950 onwards for
\Sexpr{vv$modelolder$nbsite} yellow eel time-series.
Some zero values have been excluded from the GLM analysis: 
\Sexpr{nrow(vv$modelge$value_excluded_zero)} for the glass eel model and
\Sexpr{nrow(vv$modelolder$value_excluded_zero)} for the yellow eel model. This
treatment is parcimoniuous and tests shows it has no effect on the trend (ICES,
2017).\\

The reconstructed values are then aggregated using geometric means of the two
reference area (Elsewhere Europe EE, and North Sea NS). The predictions are given 
in reference to the geometric mean of the 1960-1979 period.
Note that the shift from arithmetic to geometric means was done this year
because \textit{post-hoc} model checking confirmed that log-normal (or Gamma
Distribution) and geometric means are the prefered choice. \\

As some of the values were not complete the 2018, the
level of European eel recruitment compared to the 1960-1979 average has changed 
when compared to last year report. The value has decreased from 9.6\% in last
year report to \Sexpr{sn(100*datEE[nrow(datEE)-1,"p_std_1960_1979"], digits= 1)}\% for the Elsewhere Europe area.  It remains unchanged 
 for the North Sea at \Sexpr{sn(100*datNS[nrow(datNS)-1,"p_std_1960_1979"], digits =1)}\%.
 For 2019, data are \textbf{only provisional} and give estimates at
 \Sexpr{sn(100*datNS[nrow(datNS),"p_std_1960_1979"], digits =1)}\% for the North Sea and \Sexpr{sn(100*datEE[nrow(datEE),"p_std_1960_1979"], digits= 1)}\% for the
Elsewhere Europe area, but some of the series are not yet complete (Figure
\ref{figure5} \ref{figure5_with_logscale} (log.scale), Tables \ref{table_glm_glass_eel}).

%==========================================
\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figure5_without_logscale.png}
\caption{WGEEL recruitment index: geometric mean of estimated (GLM) glass eel
recruitment for the continental North Sea and  Elsewhere Europe series
($p$) updated to \Sexpr{CY}.
  The  GLM ($glass eel \sim area:year+site$)  was  fitted  on
  \Sexpr{vv$modelge$nbsite} time-series comprising either pure glass eel or a mixture of 
  glass eels and yellow eels. Those series were then scaled to the 1960-1979
  average $\bar{p}_{1960-1979}$. No time-series are available for glass eel in
  the Baltic area. }
\label{figure5}
\end{figure}
%==========================================

For yellow eel series, the autumn ascent has not been recorded yet and most of
the series have reported data till the middle of the summer. The 2017 yellow eel
index is confirmed at
\Sexpr{sn(100*dat_ye[nrow(dat_ye)-1,"geomean_p_std_1960_1979"])}\% of
the 1960-1979 baseline. The 2019 provisional value is
\Sexpr{sn(100*dat_ye[nrow(dat_ye),"geomean_p_std_1960_1979"])}\% and
(Figure \ref{figure6},\ref{figure6_with_logscale} (log.scale), Table
\ref{table_glm_yellow}).


%==========================================
\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figure6_without_log_scale.png}
\caption {Geometric mean of estimated (GLM) yellow eel recruitment for Europe updated to \Sexpr{CY}. The GLM ($yellow eel \sim year+site$) was fitted to
\Sexpr{vv[["nb_for_yellow_eel_glm"]]} yellow eel time-series $p$ and scaled to the
1960-1979 average $\bar{p}_{1960-1979}$.}
\label{figure6}
\end{figure}
%==========================================

\subsection{Is there a positive trend in recruitment ?}
After high levels in the late 1970s, the recruitment declined and has been very
low for all years after 2000. From ICES (2014) onward a change in the
recruitment has been detected. One of the test used to show that change in 2014
was based on SGIPEE(2011) working group. We have used a test different from that
of ICES 2011. The difference is that the model is now based on individual series
as source data, not only the prediction. The model differs from that used by
wgeel also as year is here treated as a continuous value, whereas it is treated
as a factor in the glm for recruitment, and the years are restricted to
decreasing part of the recruitment (after 1980).
\begin{equation}
glass~eel \sim  \alpha_{site} site + \beta_{area} Y_{>=1980} + \gamma_{area} Y_{>2011} + \epsilon,
\end{equation}
where glass eel is the number of glass eel in the glass eel series, either for the Elsewhere Europe or the North Sea time series, $year_{year>1980}$
is a continuous value corresponding to year after 1980, $year_{year>2011}$ is also
a continuous value, $\epsilon$ is a random error with mean 0 and standard deviation sigma, 
and $\alpha_{site}$, $\beta_{area}$ and $\gamma_{area}$ are the estimated
parameters. The parameters $\gamma_{area}$ are higly significant both in the
Elsewhere Europe area (p=\Sexpr{sn(sgipee_test_for_change_ee,digits=1)}
and for the North Sea p=\Sexpr{sn(sgipee_test_for_change_ns,digits=1)} North Sea.
This result confirms that there has been a change in the recruitment slope.

\textcolor{purple}{Add a table with past coeff, current coeff, and probabilities and diminish the text}

To test whether there is an increase in recruitment since 2011 the slope of
$\beta_{area}+\gamma_{area}$, i.e. the slope of the recent increase in
recruitment is positive, the NULL hypothesis $H0:b>0$ is tested.

To summarize, after high levels in the late 1970s, the recruitment declined and has been very
low for all years after 2000. There has been a change in the trend in 2011, the
recruitment has stopped to decrease, and has been increasing in the period
2011-2019 with a rate significantly different from zero. However, first, not all series have been reported for 2019 and the results might
change when those are reported.
Secondly, the overall recruitment remains low and the values have been lower
than the maximum values reached in 2014 for three years.


\tiny
\input{\Sexpr{str_c(tabwd,"/table_glm_glass_eel.tex")}}
\input{\Sexpr{str_c(tabwd,"/table_glm_yellow.tex")}}
\normalsize

\clearpage

\section*{Annex}

\subsection{Additional figures}

We provide the same figures as in the main text but Figure \ref{figure3withoutlogscale} 
without log scale for Figure \ref{figure3}. For the prediction, figures with log
scales are provided (Figures \ref{figure5_with_logscale} and
\ref{figure6_with_logscale}).

%==========================================
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{figure3withoutlogscale.png}
\caption{Same as figure \ref{figure3} but without log scale}
\label{figure3withoutlogscale}
\end{figure}
%==========================================
%==========================================
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{figure5.png}
\caption{Same as figure \ref{figure5} but with a log scale.}
\label{figure5_with_logscale}
\end{figure}
%==========================================
%==========================================
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{figure6.png}
\caption{Same graph as figure \ref{figure6} but with a log scale.}
\label{figure6_with_logscale}
\end{figure}
%==================================================





 

 \subsection{Notes to ACOM}
 
 \textcolor{Plum}{Were there comments raised last year ?}

 \subsection{Shiny tab on data visualisation}
 
 \dots{}
\end{document}