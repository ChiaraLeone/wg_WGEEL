---
title: "Report on developments on the state of the European eel (Anguilla anguilla) stock, the fisheries on it and other anthropogenic impacts"
author: "Hilaire"
date: "2022-09-13"
documentclass: article
output: 
  bookdown::word_document2:
    fig_caption: yes
    number_sections: no
    reference_docx: "../Rmarkdown/ICES_template.docx"

---

```{r setup, include=FALSE, warning = FALSE, message = FALSE, error=FALSE}


library(knitr)
opts_knit$set(eval.after = "fig.cap", echo=FALSE, warning = FALSE, message = FALSE, error=FALSE)
Sys.setlocale("LC_ALL", "English_United States.932")
#options(save.defaults = list(version=2))
# Password are stored in R/etc/Rprofile.site
# For the moment the database is stored locally
CY <- 2022 # current year ==> dont forget to update the graphics path below
opt_calculation <- "geomean" # "geomean" or "mean"
opt_std <- "all" #"1979-1994" or "2000-2009" or "all"

options(width=90) # this sets the width of the output
#--------------------------------
# packages used by this script
#--------------------------------
#if(!require(RODBC)) install.packages("RODBC") ; require(RODBC)
library(flextable)
if(!require(officedown)) install.packages("officedown") ; require(officedown)
if(!require(officer)) install.packages("officer") ; require(officer)
if(!require(tibble)) install.packages("tibble") ; require(tibble)
if(!require(stringr)) install.packages("stringr") ; require(stringr)

if(!require(mgcv)) install.packages("mgcv") ; require(mgcv)
if(!require(car)) install.packages("car") ; require(car)
if(!require(ggplot2)) install.packages("ggplot2") ; require(ggplot2)
if(!require(reshape)) install.packages("reshape") ; require(reshape)
if(!require(reshape2)) install.packages("reshape2") ; require(reshape2)
if(!require(stacomirtools)) install.packages("stacomirtools") ; require(stacomirtools) # for ODBC connections
if(!require(stringr)) install.packages("stringr") ; require(stringr)
if(!require(Hmisc)) install.packages("Hmisc") ; require(Hmisc)
if(!require(xtable)) install.packages("xtable") ; require(xtable)
if(!require(grid)) install.packages("grid") ; require(grid)
if(!require(sqldf)) install.packages("sqldf") ; require(sqldf)
if(!require(RPostgreSQL)) install.packages("RPostgreSQL") ; require(RPostgreSQL)
if(!require(RColorBrewer)) install.packages("RColorBrewer") ; require(RColorBrewer)
#if(!require(stacomiR)) install.packages("stacomiR") ; require(stacomiR)
if(!require(dplyr)) install.packages("dplyr") ; require(dplyr)
if(!require(boot)) install.packages("boot") ; require(boot)
if(!require(MASS)) install.packages("MASS") ; require(MASS)
if(!require(lme4)) install.packages("lme4") ; require(lme4)
if(!require(multcomp)) install.packages("multcomp") ; require(multcomp)
if(!require(openxlsx)) install.packages("openxlsx") ; require(openxlsx)
if(!require(getPass)) install.packages("getPass") ; require(getPass)
if(!require(yaml)) install.packages("yaml") ; require(yaml)


set_flextable_defaults(
  font.size = 8.5, font.family = "Calibri",
  font.color = "black",
  table.layout = "autofit",
  border.color = "black",
  theme_fun=theme_booktabs)

redtext <- fp_text(color = 'red', bold = TRUE)
purpletext <- fp_text(color = 'purple', bold = TRUE)

#--------------------------------
# get your current name 
#--------------------------------
getUsername <- function(){
	name <- Sys.info()[["user"]]
	return(name)
}



if (getUsername() == "cedric.briand") setwd("C:/workspace/wg_WGEEL/R/recruitment") 
if (getUsername() == "hilaire.drouineau") setwd("/home/hilaire.drouineau/Documents/Bordeaux/migrateurs/WGEEL/github/wg_WGEEL/R/recruitment") 
if (getUsername() == "hamme005") setwd("C:/Tessa/wg_WGEEL/R/recruitment") 
#baseODBC=c("wgeel","wgeel",passwordwgeel) #"w3.eptb-vilaine.fr" "localhost" "wgeel" "wgeel_distant" 
cred=read_yaml("../../credentials.yml")
# TODO 2022 use this to connect, not sqldf !!!!!!!!!!!!!!
# currently still using sqldf and RpostgreSQL() change for compatibility with linux
pwd = passwordwgeel = password=cred$password
con = dbConnect(RPostgres::Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=pwd)

wddata <- getwd()
wd <- wddata
#wddata <- gsub("C:/workspace/gitwgeel/R","C:/workspace/wgeeldata",wd)

datawd <- str_c(wddata,"/",CY,"/data/")
imgwd <- str_c(wddata,"/",CY,"/image/")
tabwd <- str_c(wddata,"/",CY,"/table/")
#shpwd <- str_c("C:/workspace/wgeeldata/shp/") 
shinywd <-  str_c(wddata,"/../shiny_data_visualisation/shiny_dv/data/recruitment/")
dir.create(str_c(wddata,"/",CY),showWarnings = FALSE)
dir.create(datawd, showWarnings = FALSE)
dir.create(imgwd, showWarnings = FALSE)
dir.create(tabwd, showWarnings = FALSE)

source('utility_functions.R')
graphics.off() # close all graphics devices
# the results will be stored in a list, when I first run the program,
# on the second run this list will be loaded and I can avoid some steps in the calculation
# by setting the chunks as eval=FALSE
vv <- list()

```




```{r load_database, echo=FALSE, fig.show='hide', eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
# In this chunk everything will be loaded. 
# The data selection is made tranparently later in the chunk "select_series"
# This chunks uses the RequeteODBC connection object from stacomirtools and sqldf
# an odbc link must be configured to the database : i.e. you must have the postgres
# database available, and an ODBC link pointing to the database.
# If you don't and still want to run this script, ask Cï¿½dric cedric.briand@eptb-vilaine.fr
# he will send you the Rdata saved during this chunk.

options(sqldf.RPostgreSQL.user = cred$user, 
		sqldf.RPostgreSQL.password = passwordwgeel,
		sqldf.RPostgreSQL.dbname = cred$dbname,
		sqldf.RPostgreSQL.host = cred$host, # "localhost"
		sqldf.RPostgreSQL.port = 5432) # 5435 launch the ssh tunnel

##########################"
# Description of the series -------------------------------
##########################

query ='select 
		ser_id, ser_nameshort, ser_namelong, ser_typ_id, ser_effort_uni_code,
		ser_comment, ser_uni_code, ser_lfs_code, ser_hty_code, ser_locationdescription,
		ser_emu_nameshort, ser_cou_code, ser_area_division, ser_x, ser_y,             
		ser_sam_id, ser_qal_id, ser_qal_comment,     
		"tblCodeID", "Station_Code", "Country", "Organisation", "Station_Name",       
		cou_code, cou_country, cou_order, cou_iso3code,
		lfs_code, lfs_name, lfs_definition,              
		ocean,  subocean, f_area, f_subarea,  f_division
		from datawg.t_series_ser 
		left join ref.tr_station on ser_tblcodeid=tr_station."tblCodeID"
		left join ref.tr_country_cou on cou_code=ser_cou_code 
		left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
		left join ref.tr_faoareas on ser_area_division=f_division
		where ser_typ_id=1'

R_stations= sqldf(query)



##########################
# Main data from the series -------------------------------
##########################

query='SELECT 
		das_id,
		das_value,       
		das_year,
		das_comment,
		/* 
		-- below those are data on effort, not used yet
		
		das_effort, 
		ser_effort_uni_code,       
		das_last_update,
		*/
		/* 
		-- this is the id on quality, used from 2018
		-- to remove the data with problems on quality from the series
		-- see WKEEKDATA (2018)
		das_qal_id,
		*/ 
		ser_id,            
		cou_order,
		ser_nameshort,
		ser_area_division,
		ser_qal_id,
		ser_y,
		/* 
		-- this is the id on quality at the level of individual lines of data
		-- checks are done later to ensure provide a summary of the number of 0 (missing data),
		-- 3 data discarded, 4 used but with doubts....
		*/ 
		das_qal_id,
		das_last_update,
		f_subarea,
		f_division,
		lfs_code,          
		lfs_name
		from datawg.t_dataseries_das 
		join datawg.t_series_ser on das_ser_id=ser_id
		left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
		left join ref.tr_faoareas on ser_area_division=f_division
		left join ref.tr_country_cou on  cou_code=ser_cou_code
		where ser_typ_id=1'

wger_init=sqldf(query) # (wge)el (r)ecruitment data
wger_init <- chnames(wger_init,
		c("das_id","das_value","das_year","ser_nameshort","ser_area_division","lfs_name"),
		c("id","value","year","site","area_division","lifestage"))


query <- paste0("SELECT * FROM datawg.t_series_ser join  datawg.t_dataseries_das ON das_ser_id = ser_id
				WHERE das_year in(", paste(CY,CY-1,sep=",",collapse=","),") AND das_qal_id IN (0,3,4) and ser_typ_id=1;")
last_years_with_problem <- sqldf(query)

##########################
# When were the series included -------------------------------
##########################
query='SELECT * FROM datawg.t_seriesglm_sgl'
inclusion <- sqldf(query)
############################################################################
# Rebuilding areas used by wgeel (North Sea, Elswhere Europe) from area_divisions
# See Ices (2008) for the reason why we need to do that
# We cannot use just one series, as the series from the North Sea have dropped more
# rapidly than the others, and are now at a much lower level.
# Some of that drop might be explained by decreasing catch in some of the semi-commercial
# catch and trap and transport series (Ems, Vidaa) but it also concerns fully scientific
# Estimates....
###############################################################################
wger_init[,"area"] <- NA
# below these are area used in some of the scripts see wgeel 2008 and Willem's Analysis 
# but currently wgeel only uses two areas so the following script is kept for memory
# but mostly useless
wger_init$area2[wger_init$f_subarea%in%'27.4'] <- "North Sea"
wger_init$area2[wger_init$f_subarea%in%'27.3'] <- "Baltic"
wger_init$area2[wger_init$f_subarea%in%c('27.6','27.7','27.8','27.9')] <- "Atlantic"
wger_init$area2[wger_init$f_subarea%in%c('37.1','37.2','37.3')] <- "Mediterranean Sea"
wger_init[wger_init$area2%in%c("Atlantic","Mediterranean Sea"),"area"] <- "Elsewhere Europe"
# We consider that the series of glass eel recruitment in the Baltic are influenced
# similarly in the Baltic and North Sea. This has no effect on Baltic data
wger_init[wger_init$area2%in%c("Baltic","North Sea"),"area"] <- "North Sea"

wger_init$isBaltic <- wger_init$f_division %in% c("27.3.d", "27.3.b, c")



#check if all series have been assign to an area
if (sum(is.na(wger_init$area))>0) {
	
	cat("sites with qal_id 1 or 4 and no ref")
	wger_init %>% dplyr::filter(is.na(area)&(ser_qal_id==1|ser_qal_id==4)) %>% dplyr::select(site) %>% distinct()
	cat("sites with qal_id 0 and no ref")
	wger_init %>% dplyr::filter(is.na(area)&ser_qal_id!=1) %>% dplyr::select(site) %>% distinct()
	stop("At least one series has not been affected to an area, stop this script NOW and check !!!")
}
wger_init$area <- as.factor(wger_init$area)
# We will also need this for summary tables per recruitment site, here we go straight to 
# the result
R_stations[,"area"] <- NA
R_stations$area[R_stations$f_subarea%in%c('27.4','27.3')] <- "North Sea"
R_stations$area[R_stations$f_subarea%in%c('27.6','27.7','27.8','27.9','37.1','37.2','37.3')] <- "Elsewhere Europe"
#REMOVE THIS !!!!!!!!!!!
#R_stations$area[is.na(R_stations$area)]<-"Elsewhere Europe"
#wger_init$area[is.na(wger_init$area)]<-"Elsewhere Europe"


stopifnot(all(!is.na(R_stations$f_subarea)))

# Check that there was no error in the query (while joining foreign table)
stopifnot(all(!duplicated(wger_init$id)))
# creates some variables
wger_init$decade=factor(trunc(wger_init$year/10)*10)
wger_init$year_f=factor(wger_init$year)
wger_init$decade=factor(wger_init$decade,level=sort(unique(as.numeric(as.character(wger_init$decade)))))
wger_init$ldata=log(wger_init$value)
wger_init$lifestage=as.factor(wger_init$lifestage)

# This is a view (like the result of a query) showing a summary of each series, including first year, last year,
# and duration
statseries <- sqldf('select site,namelong,min,max,duration,missing,life_stage,sampling_type,unit,habitat_type,"order",series_kept, ser_cou_code country
				from datawg.series_summary s left join datawg.t_series_ser on site=ser_nameshort where s.ser_typ_id=1')
# bug created by integer64 type when reading from the db
statseries$missing <- as.integer(statseries$missing)
save(wger_init,file=str_c(datawd,"wger_init.Rdata"))
save(statseries,file=str_c(datawd,"statseries.Rdata"))
save(R_stations,file=str_c(datawd,"R_stations.Rdata"))
save(last_years_with_problem,file=str_c(datawd,"last_years_with_problem.Rdata"))
write.table(R_stations, sep=";",file=str_c(datawd,"R_stations.csv"))


save(wger_init,file=str_c(shinywd,"wger_init.Rdata"))
save(statseries,file=str_c(shinywd,"statseries.Rdata"))
save(R_stations,file=str_c(shinywd,"R_stations.Rdata"))
save(inclusion, file=str_c(shinywd,"inclusion.Rdata"))
```



```{r load_rdata, echo=FALSE, fig.show='hide', eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
# In this rchunk we load the data even if there is no connection to the database
load(file=str_c(datawd,"wger_init.Rdata"))
load(file=str_c(datawd,"statseries.Rdata"))
load(file=str_c(datawd,"R_stations.Rdata"))
load(file=str_c(datawd,"last_years_with_problem.Rdata"))
stopifnot(all(!is.na(R_stations$area)))
if(sum(is.na(wger_init$area))>0) stop("At least one series has not been affected to an area")
```


```{r select_series, echo=FALSE, fig.show='hide', eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#% 				SERIES SELECTION AND STATISTICS ABOUT DATA ENTRY 
#% the statistics about the series are usefull while filling in new data, to check
#% which series have been already entered and which still need to be
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# wger_init is used to keep the "whole" dataset, just in case we mess with it afterwards
wger <- wger_init

vv$nb_series_init <- length(unique(wger$site)) # this is the true number at the beginning

# Series with qal_id = 0 and spanning more than ten years, along with their true length ?

left_join(
		wger_init %>% dplyr::group_by(ser_id, site, ser_qal_id) %>%
				dplyr::summarize(span=max(year)-min(year)+1) %>% 
				mutate(sup10=span>=10) %>%
				filter(ser_qal_id %in% c(0,3) & sup10)%>%
				dplyr::select(site,ser_qal_id,span ),
		wger_init %>% group_by(ser_id, site, ser_qal_id) %>%
				filter(!is.na(value)) %>% 
				dplyr::summarize(len=n()) %>% 
				dplyr::select(site, len)
)%>%	print(n=Inf) 

# Series with qal_id = 1 and spanning less than ten years, number consecutive years ?

left_join(
		wger_init %>% group_by(ser_id, site, ser_qal_id) %>%
				dplyr::summarize(span=max(year)-min(year)+1) %>% 
				mutate(sup10=span<10) %>%
				filter(ser_qal_id %in% c(1,4) & sup10)%>%
				dplyr::select(site,span, ser_qal_id),
		wger_init %>% group_by(ser_id, site, ser_qal_id) %>%
				filter(!is.na(value)) %>% 
				dplyr::summarize(len=n()) %>% 
				dplyr::select(site, len)
)%>%	print(n=Inf) 

# Here I'm using the interface with series to edit / modify series.

(vv$ser_qal_id_count <- wger_init %>% group_by(ser_qal_id) %>% distinct(ser_id) %>%dplyr::summarize(len=n()))
wger <- wger[wger$ser_qal_id==1|wger$ser_qal_id==4,]


vv$nb_series_init_qual1 <- length(unique(wger$site))

# check on series discarded -----------------------------------------------

# So far I haven't automated the decision rule to only integrate new series if they
# are more than 10 year long. So each year we have to check. Some of the series have been
# discared for other reasons and this is stated in column eel_qal_comment of the t_series_ser table

wgerdiscarded <- wger_init[wger_init$ser_qal_id!=1,]

# series marked as "0" might have a very low value but not included in the analysis, here replaced by NA
wgerdiscarded$value[wgerdiscarded$das_qal_id==0] <- NA
# storing this information in a list for eventual later display and check
vv$length_discarded <- tapply(wgerdiscarded$value,wgerdiscarded$site,function(X) sum(!is.na(X)))
# below comments for 2018 after checking the series
# Farp (Farpener Bach DE) 11 years long enough but stocking influence 
# DoFp (Fyke on yellow eel) 13 years but fyke nets yellow catch, not really recruitment
# SeHM (35 year) duplicates

# Treating individual eel_qal_comment on the series
# In some series and for some years, there might be a value, and a good reason not to
# consider that value, e.g. hydropower station on which the pass is built only operated after
# the recruitment season, or local conditions making it impossible to evaluate recruitment.
# Series with no data have das_qal_id = 0
# Series with data to be removed have eel_qal_id = 3
# Series about which we have serious doubts but that we choose to keep have eel_qal_id = 4

# All values labelled 0 must have no data 
should_be_na <-  wger[!is.na(wger$das_qal_id) & wger$das_qal_id==0 & is.na(wger$das_value),c("value")]
should_be_na_id <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==0 & is.na(wger$das_value),c("id")]

if (! all(is.na(
				should_be_na
		)))
	stop("Rows with id", paste(should_be_na_id[which(!is.na(should_be_na))],collapse=","), 
			" with qal_id 0 should be NA")

# Checking series with eel_qal_id 3 (wrong data to be ignored) -------------------------------------

removed_id <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==3,c("id")] 
removed_year <-  wger[!is.na(wger$das_qal_id)&wger$das_qal_id==3,c("year")]
removed_site <-  unique(wger[!is.na(wger$das_qal_id)&wger$das_qal_id==3,c("site")])
warnings("Rows with ids: ", paste(removed_id,collapse=","),     
		" years: ", paste(removed_year,collapse=","),
		" sites: ", paste(removed_site,collapse=","),     
		" with qal_id = 3 removed from analysis")
vv$qual_id_3_removed <- list()
vv$qual_id_3_removed$length <- length(removed_id)
vv$qual_id_3_removed$year <- removed_year
vv$qual_id_3_removed$site <- removed_site




# For those series, values are replaced with NA -----------------------------------------------------

wger[!is.na(wger$das_qal_id) & wger$das_qal_id==3,c("value")] <- NA

#########################################################################
# standardizing with 2000-2009
# this was a question asked by ACFM ? 2014 ?
# so it's still done, we produce a graph but don't show it
# as it might confuse the reader
##########################################################################

mdata <- wger[wger$year>=2000 & wger$year<2010,]
std_site <- unique(mdata$site[order(mdata$site)])
# length(std_site) 
site <- unique(wger$site[order(wger$site)])
# length(site)  #52
unused_series_2000_2009  <-  site[!site%in%std_site] # series not having data between 2000 and 2009 # "Vida" "YFS1" 
vv$sc_2000_2009_unused_series <- unused_series_2000_2009
vv$sc_2000_2009_nb <- vv$nb_series_init_qual1-length(vv$sc_2000_2009_unused_series)
#add a column to R_station for flagging unused series
R_stations$unused_2000_2009  <-  FALSE
R_stations[R_stations$rec_nameshort %in% unused_series_2000_2009, "unused_2000_2009"]  <-  TRUE
#ex(std_site)
# Inag and Maig left out from the analysis 
mean_site <- data.frame(mean_2000_2009=tapply(mdata$value,mdata$site,mean,na.rm=TRUE))
mean_site$site <- rownames(mean_site)
wger <- merge(wger,mean_site,by="site",all.x=TRUE,all.y=FALSE) # here we loose the two stations Inag and Maig and also Frï¿½mur
wger$value_std_2000_2009 <- wger$value/wger$mean_2000_2009

#########################################################################
#standardizing with mean from 1979-1994
##########################################################################

mdata <- wger[wger$year>=1979 & wger$year<1994,]
std_site <- unique(mdata$site[order(mdata$site)])
# length(std_site) # 45
site <- unique(wger$site[order(wger$site)])
# length(site) #49
unused_series_1979_1994 <- site[!site%in%std_site] # "Bres" "Fre"  "Inag" "Klit" "Maig" "Nors" "Sle"  "Vac"
vv$sc_1979_1994_unused_series <- unused_series_1979_1994
vv$sc_1979_1994_nb <- vv$nb_series_init_qual1-length(vv$sc_1979_1994_unused_series)
#add a column to R_station for flagging unused series
R_stations$unused_1979_1994  <-  FALSE
R_stations[R_stations$rec_nameshort %in% unused_series_1979_1994, "unused_1979_1994"]  <-  TRUE
mean_site <- data.frame(mean_1979_1994=tapply(mdata$value,mdata$site,mean,na.rm=TRUE))
mean_site$site <- rownames(mean_site)
wger <- merge(wger,mean_site,by="site",all.x=TRUE,all.y=FALSE) 
wger$value_std_1979_1994 <- wger$value/wger$mean_1979_1994

#########################################################################
#standardizing with mean (all data)
##########################################################################

mean_site <- data.frame(mean = tapply(wger$value,wger$site,mean,na.rm=TRUE))
mean_site$site <- rownames(mean_site)
wger <- merge(wger,mean_site,by="site",all.x=TRUE,all.y=FALSE) 
wger$value_std <- wger$value/wger$mean


#########################################################################
#separating glass eel and yellow eels
##########################################################################


glass_eel_yoy <- wger[wger$lifestage!="yellow eel" & wger$year>1959,] #glass eel and yoy
older <- wger[wger$lifestage=="yellow eel" & wger$year>1949,] # Advice Drafting 2017 asks to 
# give from 1949 to be consistent with previous years

##########################################################################
# Some statistics for later use, nb of year per series
#########################################################################

nb_year <- colSums(ftable(xtabs(formula = value_std_1979_1994~year+site,data=wger))>0)
names(nb_year) <- colnames(xtabs(formula = value_std_1979_1994~year+site,data=wger))

###############################################################
# some other statistics used there
###############################################################

nb_series_glass_eel <- length(unique(glass_eel_yoy$site)) # this will be reported in the pdf later
vv$nb_series_glass_eel <- nb_series_glass_eel

vv$nb_series_glass_eel_per_area <-glass_eel_yoy %>% distinct(site, area) %>% group_by(area)%>%dplyr::summarize(n())
nb_series_older <- length(unique(older$site)) # this will be reported in the pdf later
vv$nb_series_older <- nb_series_older
nb_series_final <- nb_series_glass_eel+nb_series_older
vv$nb_series_final <- nb_series_final


###############################################################
# Finally saving the data
###############################################################

save(wger, file = paste0(datawd, "wger.Rdata"))
save(older, file = paste0(datawd, "older.Rdata"))
save(glass_eel_yoy, file = paste0(datawd, "glass_eel_yoy.Rdata"))

save(wger, file = paste0(shinywd,"wger.Rdata"))
save(older, file = paste0(shinywd,"older.Rdata"))
save(glass_eel_yoy, file = paste0(shinywd, "glass_eel_yoy.Rdata"))


#load(paste(datawd,"wger.Rdata",sep="/"))
#load(paste(datawd,"older.Rdata",sep="/"))
#load(paste(datawd,"glass_eel_yoy.Rdata",sep="/"))
write.table(glass_eel_yoy,file=str_c(datawd,"glass_eel_yoy.csv"), sep=";")
write.table(older,file=str_c(datawd,"older.csv"), sep=";")
```


```{r table_series,echo=FALSE, eval=TRUE,fig.show='hide', results="hide", warning = FALSE, message = FALSE, error=FALSE}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%				THIS CHUNK CREATES THE TABLES	
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


last_year <- tapply(wger$year,wger$site, function(X) max(X))
#stations updated to",CY
R_stations$areashort <- "EE"
R_stations$areashort[R_stations$area=="North Sea"] <- "NS"
R_stations$ser_namelong <- iconv(R_stations$ser_namelong,"UTF8")

series_CY <- R_stations[R_stations$ser_nameshort%in%names(last_year[last_year==CY]),
		c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division","ser_qal_id","cou_order","ser_y")]
#series_CY <- merge(series_CY,last_years_with_problem[,c("das_qal_id", "ser_nameshort")], by="ser_nameshort", all.x=T)
#series_CY$das_qal_id[is.na(series_CY$das_qal_id)] <- 1

series_CY <- series_CY[order(series_CY$ser_lfs_code,series_CY$cou_order),-c(ncol(series_CY)-1,ncol(series_CY))]
#series_CY <- series_CY[order(series_CY$ser_lfs_code,series_CY$cou_order),	c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division")]

vv$nCY <- nrow(series_CY) # number of series updated to the current year (for later use)
vv$nCYG <- nrow(series_CY[series_CY$ser_lfs_code=="G",]) # number of series with glass eel updated to the current year
vv$nCYGY <- nrow(series_CY[series_CY$ser_lfs_code=="GY",]) # number of series with glass eel updated to the current year
vv$nCYY <- nrow(series_CY[series_CY$ser_lfs_code=="Y",]) # number of series with yellow eel (only) updated to the current year

#"stations updated to",CY-1
series_CYm1 <- R_stations[R_stations$ser_nameshort%in%names(last_year[last_year==CY-1]),
		c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division","cou_order","ser_y")]
series_CYm1 <- series_CYm1[order(series_CYm1$ser_lfs_code,series_CYm1$cou_order),c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division")]
vv$nCYm1 <- nrow(series_CYm1) # number series updated last year only (and not this year)
vv$nCYm1G <- nrow(series_CYm1[series_CYm1$ser_lfs_code=="G",]) # same for glass eel 
vv$nCYm1GY <- nrow(series_CYm1[series_CYm1$ser_lfs_code=="GY",]) # same for glass eel 
vv$nCYm1Y <- nrow(series_CYm1[series_CYm1$ser_lfs_code=="Y",]) # same for yellow eel only

# Series that have not been updated for two years
lost_ones <- last_year[last_year<CY-1]
d_lost_ones <- data.frame("site"=names(lost_ones),"year"=lost_ones) # data frame
series_lost <- merge(
		R_stations[R_stations$ser_nameshort%in%names(lost_ones),c(c("ser_nameshort","ser_namelong","cou_code","ser_lfs_code","areashort","ser_area_division"))],
		d_lost_ones,
		by.y="site",by.x="ser_nameshort")
series_lost <- series_lost[order(series_lost$year),]
vv$nseries_lost <- nrow(series_lost) # number of series not updated for the two last years
vv$nseries_lostG <- nrow(series_lost[series_lost$ser_lfs_code=="G",])
vv$nseries_lostY <- nrow(series_lost[series_lost$ser_lfs_code=="Y",])
vv$nseries_lostGY <- nrow(series_lost[series_lost$ser_lfs_code=="GY",])
#xtable of current year series


#------------------------------------------------------
# we use xtable to transform the table to a latex format
#------------------------------------------------------


colnames(series_CY) <-c("Site","Name","Coun.","Stage","Area","Division", "Kept")

xseries_CY <- xtable(x = series_CY,
		label = "table_seriesCY",
		caption = str_c("Series updated to ",CY, ". Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Area NS = North Sea, EE = Elsewhere Europe, Division = FAO marine division. Series ordered by stage and from North to South"),
		align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}", "p{1cm}","p{1.4cm}"))
print(xseries_CY, file = str_c(	tabwd,"/table_seriesCY.tex"),
		table.placement = "htbp",
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		tabular.environment="tabularx",
		width="\\textwidth",
		include.rownames=FALSE
)

#------------------------------------------------------
# xtable of series current year minus one
#------------------------------------------------------

colnames(series_CYm1) <- c("Site","Name","Coun.","Stage","Area","Division")
xseries_CYm1 <- xtable(x = series_CYm1,
		label = str_c("table_seriesCYm1"),
		caption = str_c("Series updated to ",CY-1, " see table \\@ref(tab:table_seriesCY) for codes. Series ordered from North to South"),
		align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}"))

print(xseries_CYm1, 
		file = str_c(tabwd,"/table_seriesCYm1.tex"),
		table.placement = "htbp",
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		tabular.environment="tabularx",
		width="\\textwidth",
		include.rownames=FALSE
)
#------------------------------------------------------
# xtable of series that have not been updated
#------------------------------------------------------
colnames(series_lost) <- c("Site","Name","Coun.","Stage","Area","Division","Last Year")
xseries_lost <- xtable(x = series_lost,
		label = str_c("table_serieslost"),
		caption = str_c("Series stopped or not updated to ",CY-1, " see table \\@ref(tab:table_seriesCY) for codes. Series ordered by last year"),
		align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}","p{1.2cm}"))
print(xseries_lost, 
		file = str_c(tabwd,"/table_serieslost.tex"),
		table.placement = "htbp",
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		tabular.environment="tabularx",
		width="\\textwidth",
		include.rownames=FALSE
)
# number of series per area per year
area_year=table(glass_eel_yoy$year,glass_eel_yoy$area)
# number of series per stage per year
n_y_lfs <- reshape2::dcast(wger,year~lifestage,length,value.var="year")
n_y_lfs$sum <- rowSums(n_y_lfs[,c(2:4)])
colnames(n_y_lfs) <- c("year","glass","glass+yellow","yellow","sum")
rownames(n_y_lfs) <- n_y_lfs$"year"
#xn_y_lfs <- xtable(x = n_y_lfs, 
#		label = "table_n_y_lfs",
#		caption = str_c("Numer of series per stage per year"))
#print(xn_y_lfs, file = str_c(tabwd,"/table_n_y_lfs.tex"), 
#		table.placement = "htbp",
#		caption.placement = "top",
#		NA.string = ".")

#n_area_styp <- reshape2::dcast(wger,area~sampling_type,length,value.var="area")
#n_y_area <- reshape2::dcast(wger,year~area,length,value.var="area")
#n_y_area$sum <- rowSums(n_y_area[,c(2,3)])
#rownames(n_y_area) <- n_y_area$year
##xn_y_area <- xtable(x = n_y_area, 
##		label = str_c("table_n_y_area"),
##		caption = str_c("Number of series per geographical area per year"),
##		digits=0)
##print(xn_y_area, 
##		file = str_c(tabwd,"/table_n_y_area.tex"), 
##		table.placement = "htbp",
##		caption.placement = "top",
##		NA.string = ".")

printstatseries <- statseries[,c(1,13,3,4,5,6,7,8,9,10,11,12)]
printstatseries$sampling_type[printstatseries$sampling_type=="scientific estimate"] <- "sci. surv."
printstatseries$sampling_type[grep("trap",printstatseries$sampling_type)] <- "trap"
printstatseries$sampling_type[printstatseries$sampling_type=="commercial catch"] <- "com. catch"
printstatseries$sampling_type[printstatseries$sampling_type=="commercial CPUE"] <- "com. cpue"
column_to_import <- R_stations[,c("ser_nameshort","areashort")]
printstatseries <- merge(printstatseries,column_to_import,by.x="site",by.y="ser_nameshort")
printstatseriesGNS <- printstatseries%>% 
		filter(life_stage=="G", areashort=="NS")%>%
		arrange(order,site)%>%
		dplyr::select("life_stage","areashort","country","site","min","max","missing","duration","missing","sampling_type","unit","habitat_type","series_kept")%>%
		dplyr::rename("code"="site",
				"area"="areashort",
				"n+"="duration",
				"n-"="missing", 
				"life stage"="life_stage", 
				"sampling type"="sampling_type",
				"habitat"="habitat_type",
				"kept"="series_kept")

xstatseriesGNS <- xtable(x = printstatseriesGNS, 
		label = str_c("statseriesG"),
		caption = str_c("Short description of the sampling sites for European eel recruitment data in the North Sea. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses."),
		align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
		digits=0)

print(xstatseriesGNS , 
		file = str_c(tabwd,"/table_statseriesGNS.tex"),
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		include.rownames=FALSE
)

printstatseriesGEE <- printstatseries%>% 
		filter(life_stage=="G", areashort=="EE")%>%
		arrange(order,site)%>%
		dplyr::select("life_stage","areashort","country","site","min","max","missing","duration","missing","sampling_type","unit","habitat_type","series_kept")%>%
		dplyr::rename("code"="site",
				"area"="areashort",
				"n+"="duration",
				"n-"="missing", 
				"life stage"="life_stage", 
				"sampling type"="sampling_type",
				"habitat"="habitat_type",
				"kept"="series_kept")

xstatseriesGEE <- xtable(x = printstatseriesGEE, 
		label = str_c("statseriesG"),
		caption = str_c("Short description of the sampling sites for European eel recruitment data for Elsewhere Europe. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses."),
		align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
		digits=0)

print(xstatseriesGEE , 
		file = str_c(tabwd,"/table_statseriesGEE.tex"),
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		include.rownames=FALSE
)



printstatseriesGY <- printstatseries %>% 
		filter(life_stage=="GY") %>%
		arrange(order, site) %>%
		dplyr::select("life_stage","areashort","country","site","min","max","missing","duration","missing","sampling_type","unit","habitat_type","series_kept") %>%
		dplyr::rename("code"="site",
				"area"="areashort",
				"n+"="duration",
				"n-"="missing", 
				"life stage"="life_stage", 
				"sampling type"="sampling_type",
				"habitat"="habitat_type",
				"kept"="series_kept")
xstatseriesGY <- xtable(x = printstatseriesGY, 
		label = str_c("statseriesGY"),
		caption = str_c("Short description of the recruitment sites (continued : stage glass eel and yellow eel)"),
		align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
		digits=0)
print(xstatseriesGY , 
		file = str_c(tabwd,"/table_statseriesGY.tex"),
		table.placement = "htbp",
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		include.rownames=FALSE
)

printstatseriesY <- printstatseries%>% 
		filter(life_stage=="Y")%>%
		arrange(order,site)%>%
		dplyr::select("life_stage","areashort","country","site","min","max","missing","duration","missing","sampling_type","unit","habitat_type","series_kept")%>%
		dplyr::rename("code"="site",
				"area"="areashort",
				"n+"="duration",
				"n-"="missing", 
				"life stage"="life_stage", 
				"sampling type"="sampling_type",
				"habitat"="habitat_type",
				"kept"="series_kept")

xstatseriesY <- xtable(x = printstatseriesY, 
		label = str_c("statseriesY"),
		caption = str_c("Short description of the recruitment sites (continued : yellow eel series) "),
		align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
		digits=0)
print(xstatseriesY, 
		file = str_c(tabwd,"/table_statseriesY.tex"),
		table.placement = "htbp",
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		include.rownames=FALSE
)

################################################################
# Table of the problem in series for this year
################################################################

series_prob <- last_years_with_problem[last_years_with_problem$ser_typ_id %in% 1,c("ser_nameshort","ser_lfs_code","ser_cou_code","ser_area_division","das_year","das_qal_id","das_comment" )]
series_prob <- series_prob[order(series_prob$ser_lfs_code,series_prob$das_year, series_prob$ser_nameshort),]
colnames(series_prob) <- c("Name","Stage", "Country","Division","Year", "Kept", "Comment")
series_prob$Comment<-iconv(series_prob$Comment,'UTF-8')
xseries_prob <- xtable(x = series_prob[1:15,],
		label = "table_series_prob",
		caption = str_c("Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
						2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
		align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
)
print(xseries_prob,
		file = str_c(	tabwd,"/table_series_prob.tex"),
		table.placement = "htbp",
		caption.placement = "top",
		sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
		NA.string = ".",
		#tabular.environment="longtable",
		include.rownames=FALSE
)
if (nrow(series_prob)>15){
	xseries_prob1 <- xtable(x = series_prob[15:30,],
			label = "table_series_prob1",
			caption = str_c("Table \\@ref(tab:table_series_prob) continued. Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
							2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
			align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
	)
	print(xseries_prob1,
			file = str_c(	tabwd,"/table_series_prob1.tex"),
			table.placement = "htbp",
			caption.placement = "top",
			sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
			NA.string = ".",
			#tabular.environment="longtable",
			include.rownames=FALSE
	)
}

if (nrow(series_prob)>30){
	xseries_prob2 <- xtable(x = series_prob[30:nrow(series_prob),],
			label = "table_series_prob2",
			caption = str_c("Table \\@ref(tab:table_series_prob) continued. Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
							2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
			align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
	)
	print(xseries_prob2,
			file = str_c(	tabwd,"/table_series_prob2.tex"),
			table.placement = "htbp",
			caption.placement = "top",
			sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
			NA.string = ".",
			#tabular.environment="longtable",
			include.rownames=FALSE
	)
}

# when have the series been more than 10 years ?
#res <- bind_rows(glass_eel_yoy,older) %>% arrange(site, year) %>% 
#		mutate(count=1) %>% 
#		group_by(site) %>% 
#		mutate(n=cumsum(count)) %>%
#		#filter(site=='BrokGY')
#		filter(n==10)%>%
#		dplyr::select(site, year)



################################################################
# some additional stats for the report
#################################################################

# in which year has there been the largest number of glass eel (or apparented) series ?
yearmaxglasseel <- n_y_lfs$year[which(max(n_y_lfs$"glass"+n_y_lfs$"glass+yellow")==n_y_lfs$"glass"+n_y_lfs$"glass+yellow")]
# and for how long ?
nbmaxglasseel <- max(n_y_lfs$"glass"+n_y_lfs$"glass+yellow")
# storing this in our nice list
vv$yearmaxglasseel <- yearmaxglasseel
vv$nbmaxglasseel <- nbmaxglasseel
vv$nbcurrentglasseel <- n_y_lfs$"glass"[n_y_lfs$year==CY]+n_y_lfs$"glass+yellow"[n_y_lfs$year==CY]
# same for yellow eel
yearmaxyellow <- n_y_lfs$year[which(max(n_y_lfs$"yellow")==n_y_lfs$"yellow")]
nbmaxyellow <- max(n_y_lfs$"yellow")
vv$yearmaxyellow <- yearmaxyellow
vv$nbmaxyellow <- nbmaxyellow
vv$nbcurrentyellow <- n_y_lfs$"yellow"[n_y_lfs$year==CY]


```


```{r figureseries, echo=FALSE,  eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dd <- as.data.frame(table(year=wger$year,lifestage=wger$lifestage))

figure2 <- ggplot(dd, aes(x=as.numeric(as.character(year)), y=Freq, group=lifestage, col=lifestage)) + geom_point() + geom_line(lwd=2) + ylab('number of series') +xlab('year')+
		theme(text=element_text(size=12))+
		scale_x_continuous(limits=c(1900,CY))+
		theme_bw()+
		theme(text = element_text(size=30),
				axis.text.x = element_text(angle=0, hjust=1))+
		theme(legend.position = c(0.25,0.75), legend.text = element_text( size = 35))
#X11(400,250)

print(figure2)
save_figure(figname="figure2",figure2,800,600)

ddd <- as.data.frame(table(year=wger$year,lifestage=wger$lifestage, area=wger$area2))

figure2.1 <- ggplot(ddd, aes(x=as.numeric(as.character(year)), y=Freq, group=lifestage, col=lifestage)) + geom_point() + geom_line(lwd=2) + ylab('number of series') +xlab('year')+
		facet_wrap(~factor(ddd$area), ncol=2) +
		theme(text=element_text(size=10))+
		scale_x_continuous(limits=c(1900,CY))+
		theme_bw()+
		theme(text = element_text(size=25),
				axis.text.x = element_text(angle=0, hjust=1))+
		# theme(legend.position = c(0.15,0.88), legend.text = element_text( size = 15),axis.text.x = element_text(angle = 45, size=16))
		theme(legend.text = element_text( size = 15),axis.text.x = element_text(angle = 45, size=16))

#X11(width=1000,height=500)

print(figure2.1)
save_figure(figname="series_no_area",figure2.1,1000,500)
```


```{r mapseries,echo=FALSE, eval=TRUE,results="hide", warning = FALSE, message = FALSE, error=FALSE,fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


# if problems see https://github.com/dkahle/ggmap/issues/160

if(!require(ggmap)) install.packages("ggmap") ; require(ggmap)
if(!require(sf)) install.packages("sf") ; require(sf)
if(!require(RPostgres)) install.packages("RPostgres") ; require(RPostgres)


load("../shiny_data_visualisation/shiny_dv/data/ref_and_eel_data.Rdata")
source("../utilities/load_library.R")
source("../shiny_data_visualisation/shiny_dv/database_connection.R")



my_map <- get_stamenmap( c(left = -13, bottom = 35, right =
						27, top = 65),zoom=4, maptype = c("watercolor"))

con <- dbConnect(Postgres(),host=cred$host,password=passwordwgeel,dbname=cred$dbname,user=cred$user)
fao <- st_read(con,query="select * from ref.tr_faoareas")
fao <- st_crop(fao, xmin = -13, xmax = 27,
		ymin = 35, ymax = 65)
fao <- st_transform(fao,3857)
fao$zone <- ifelse(fao$f_code %in% c("27.3.d",'27.3.b, c'),"Baltic",
		ifelse(startsWith(fao$f_code,"27.4.") | startsWith(fao$f_code,"27.3."),
				"North Sea",
				"Elsewhere Europe"))


ggmap_bbox <- function(map) {
	if (!inherits(map, "ggmap")) stop("map must be a ggmap object")
	# Extract the bounding box (in lat/lon) from the ggmap to a numeric vector, 
	# and set the names to what sf::st_bbox expects:
	map_bbox <- setNames(unlist(attr(map, "bb")), 
			c("ymin", "xmin", "ymax", "xmax"))
	
	# Coonvert the bbox to an sf polygon, transform it to 3857, 
	# and convert back to a bbox (convoluted, but it works)
	bbox_3857 <- st_bbox(st_transform(st_as_sfc(st_bbox(map_bbox, crs = 4326)), 3857))
	
	# Overwrite the bbox of the ggmap object with the transformed coordinates 
	attr(map, "bb")$ll.lat <- bbox_3857["ymin"]
	attr(map, "bb")$ll.lon <- bbox_3857["xmin"]
	attr(map, "bb")$ur.lat <- bbox_3857["ymax"]
	attr(map, "bb")$ur.lon <- bbox_3857["xmax"]
	map
}
my_map<- ggmap_bbox(my_map)
stations <- st_transform(st_as_sf(R_stations,coords=c("ser_x","ser_y"),crs=4326),3857)
#stations <- st_as_sf(R_stations,coords=c("ser_x","ser_y"),crs=4326)

stations$X = st_coordinates(stations)[,"X"]
stations$Y = st_coordinates(stations)[,"Y"]

figure1 <- ggmap(my_map)+  
		coord_sf(crs = st_crs(3857)) + # force it to be 3857
		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone,alpha="1")) +
		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone)) +
		geom_sf_text(data=st_centroid(fao), inherit.aes=FALSE,aes(label=f_code),cex=1.5) +
#		geom_sf(data=stations,aes(color=ser_lfs_code,shape=ser_lfs_code),size=2, inherit.aes = FALSE)+
#		geom_sf(data=subset(stations,ser_lfs_code!="Y" & ser_qal_id==1),color = 'black',size=2, shape = 21,
#				inherit.aes=FALSE) +
#		geom_sf(data=subset(stations,ser_lfs_code=="Y"& ser_qal_id==1),color = 'black',size=2, shape = 24,
#				inherit.aes=FALSE) +
		geom_point(data=stations,aes(x=X,y=Y,
						color=ser_lfs_code,shape=ser_lfs_code,stroke=0),size=3)+
		geom_point(data=subset(stations,ser_lfs_code!="Y"& ser_qal_id==1),
				color = 'black', 
				size=3, 
				shape = 21,
				stroke=1,
				aes(x=X,y=Y)) +
		geom_point(data=subset(stations,ser_lfs_code=="Y"& (ser_qal_id==1 |ser_qal_id==4)),
				color = 'black',		
				size= 3, 
				shape = 24,
				stroke =1,
				aes(x=X,y=Y)) +
		
		scale_color_manual("Life stage",values=c("white","grey","yellow")) +
		scale_shape_manual("Life stage", values=c(19,19,17)) + xlab("") + ylab("") +
		scale_fill_manual(NULL,values=c("#30ff8a","#33b1c4","#1a81db")) +
		guides(alpha=guide_legend("Recruitment series",
						legend.background = element_blank(),
						title.theme=element_text(face="bold"),
						keyheight=0,
						label.theme=element_text(size=0,lineheight=0),
						order=1, 
						override.aes=list(color=NA, shape=NA, alpha=NA, fill=NA))) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent")
		
		)
print(figure1)


save_figure("figure1",figure1,550,600)
```



```{r tableswgeel,echo=FALSE, eval=FALSE,results="hide", warning = FALSE, message = FALSE, error=FALSE}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# THIS R CHUNCK IS USED ONCE AT THE END TO GENERATE THE TABLES.
## This will fail if saved twice, run at the end of the working group to generate the table of values
wger_init$das_order <- order(wger_init$cou_order, wger_init$ser_y, wger_init$site, wger_init$year)
wger_init$ser_order <- rank(order(wger_init$cou_order, wger_init$ser_y, wger_init$site))
dat <- wger_init[wger_init$ser_order,]
dat$year=as.factor(dat$year)


tab1 <- reshape2::dcast(dat,year~site,value.var="value")
tab1[,2:ncol(tab1)]=round(tab1[,2:ncol(tab1)],2)
tab1[,1] <- as.character(tab1[,1])

statseries <- statseries[order(statseries$site),]

first_line <- c("kept",statseries$series_kept)
tab1 <- rbind(first_line,tab1)


openxlsx::write.xlsx(x=list("recruitment_series"=tab1,
				"series_description"=statseries),file=str_c(datawd,"table_rec", CY, ".xlsx"))

openxlsx::write.xlsx(x=list("wger_init"=wger_init,
				"older"=older, "wger"=wger),file=str_c(datawd,"table_long", CY, ".xlsx"))

```



# Data sources
# Recruitment

In this section, the latest trends in glass and yellow eel recruitment are
addressed. The time-series data are derived from fishery-dependent sources
(i.e. catch records) and also from fishery-independent surveys across much of
the geographic range of European eel.  The
stages are categorized as :

* glass eel (G), continental age 0 years, 
* a mixture of glass eel and young
yellow eel dominated by recruits from the same year (GY), and
* older yellow eel (Y) recruiting to continental habitats. The yellow
eel series might consist of yellow eel of several ages.
This is certainly the case for all series from the Baltic (mean age up to 6),
 some Irish sites, and sites located far upstream.

The glass eel recruitment time-series have been grouped into two geographical
areas: 'continental North Sea' (NS) and 'Elsewhere Europe' (EE) (Figure
\@ref(fig:figure1). The glass eel recruitment time-series have been grouped into two geographical
areas: 'continental North Sea' (NS) and 'Elsewhere Europe' (EE) (Figure 3.4.1).
Previous analyses by the working group (ICES, 2010b, p19, Bornarel et al. (2017) 
have shown a different trend between the two sets. This is mostly due to a more pronounced
decline of the North Sea series compared to the Elsewhere Europe area during the 1980s.

The WGEEL has collated information on recruitment from
`r vv[["nb_series_init"]]` time-series. Some time-series date back to the
beginning of 20th century (yellow eel, GÃ¶ta Ãlv, Sweden) or 1920 (glass eel,
Loire, France). Among those series `r vv[["nb_series_init_qual1"]]` have been
selected for further analysis in the wgeel indices; see details on data
selection and processing below. Depending on the standardization period, the number of series  used can be lower and is given for
each analysis. 


```{r figure1, fig.cap="Zone definition and available data", fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure1.png"))

```


## Details on data selection and processing

Out of `r vv[["nb_series_init"]]`, 
`r vv[["nb_series_final"]]` series were used in the analysis. Three
rules have been used for this selection procedure.
1. First, if there are two or more series from the same location, i.e. they are not independent,only one series is kept. For instance, the longer series has been kept for the Severn (Severn EA) while the other series (Severn HMRC) has been dropped from the list, as it was considered a duplicate being based on the same fishery.Noting that the 'Severn' here actually represents all the glass eel fisheries for England and Wales but the naming convention has been used for many
years so is retained for consistency.
`r ftext("TODO work on Minho sp and Minho pt. and Gironde....",redtext)`
2. The second rule is to exclude a series from the analysis when it is less than ten years long. The series are, however, still updated in the database until they are long enough to be included. `r ftext("But clarify now what we are going to do when there are missing years....", redtext)` 
3. Finally, it was decided to discard recruitment series that were obviously biased by restocking (e.g. Farpener Bach in Germany).


Among the time-series based on trap indices, some have reported
preliminary data for `r CY` as their trapping season had not
finished. *As usual, the indices given for `r CY` must be considered as provisional especially those for the yellow eel.*



```{r xstatseriesGEE, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Short description of the sampling sites for European eel recruitment data for Elsewhere Europe. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses.")}
autofit(flextable(data = printstatseriesGEE)%>%
          bold(bold = TRUE, part = "header"))
```


```{r xstatseriesGNS, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,tab.cap=str_c("Short description of the sampling sites for European eel recruitment data in the North Sea. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses.")}
	autofit(flextable(data = printstatseriesGNS)%>%
          bold(bold = TRUE, part = "header"))
```

```{r xstatseriesGY, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, tab.cap=str_c("Short description of the recruitment sites (continued : stage glass eel and yellow eel)")}
autofit(flextable(data = printstatseriesGY) %>%
          bold(bold = TRUE, part = "header"))
```


```{r xstatseriesY, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, tab.cap= str_c("Short description of the recruitment sites (continued : yellow eel series) ")}
autofit(flextable(data = printstatseriesY)%>%
          bold(bold = TRUE, part = "header"))
```


```{r xseriesprob, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,echo=FALSE, tab.cap=str_c("Table \\@ref(tab:xseriesprob) continued. Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality, 							2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality")}
autofit(flextable(data = series_prob[1:14,])%>%
          bold(bold = TRUE, part = "header"))
```


```{r xseriesprob1, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Table \\@ref(tab:xseriesprob) continued. Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality, 2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality")}
autofit(flextable(data = series_prob[15:30,])%>%
          bold(bold = TRUE, part = "header"))
```


```{r xseriesprob2, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Table \\@ref(tab:xseriesprob) continued. Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality, 2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality")}
autofit(flextable(data = series_prob[30:nrow(series_prob),])%>%
          bold(bold = TRUE, part = "header"))
```



## Number of series available


Glass eel and glass eel + young yellow eel time-series available maximum :
`r vv[["nbmaxglasseel"]]` in
`r max(as.numeric(vv[["yearmaxglasseel"]]))`
`r vv[["nbcurrentglasseel"]]` in `r CY`. The maximum number of older
yellow eel time-series has increased to `r vv[["nbmaxyellow"]]` in
`r max(as.numeric(vv[["yearmaxyellow"]]))` but dropped to
`r vv[["nbcurrentyellow"]]` (Figure \@ref(fig:figure2)).

```{r figure2, fig.cap="Trends in number of glass eel (black circle), glass+young yellow eel (grey triangle) and older yellow eel (black triangle) time-series giving a report in  any specific year.", fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure2.png"))
```

```{r figure2b, fig.cap="Series selection and analysis. Series less than 10 years are not used in the analysis. Y yellow eel series, G + GY glass and young yellow eel series. NS North Sea, EE Elsewhere Europe", fig.width=16/254, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
if (file.exists(paste0(imgwd,"series_no_area.png")))
  knitr::include_graphics(paste0(imgwd,"series_no_area.png"))
```


```{r generation_of_plot_data, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.show='hide'}
###################################################
# Generation of the dataframes used to plot the data
# two similar dataframe are created
# with the new ggplot2 it is no longer necessary but code was developped earlier at
# the time when such format was still necessary
# we will create a first dataframe (scal) with all the series together, this was
# the initial analysis built by Wgeel, and it is kept for historical consistency
# later on the geomean have been added , and the graph add a bootstrap calculation of the mean (bootscal)
# At some point the wgeel discussed that it might make more sense to separate
# glass eel (scalgeel) and yellow eel (scalyellow), so this graph is showing all, the geomean on all series, the
# trend for glass eel and the trend for yellow eel. This graph shows "unprocessed" data,
# as the wgeel recruitment index uses a glm index to rebuilt a consistent series.
# At some point ACFM asked to use a different scaling period and we complied but the graph
# is no longer shown as it is a bit confusing.
# below now a geom bootstrap is proposed. 
# TODO  2018 discuss whether to present arithmetic (not really good), geometric mean,
# or nothing at all (Willem's suggestion)
###################################################
sgeomean.cl.boot <- function (x, conf.int = 0.95, B = 1000, na.rm = TRUE, reps = FALSE) 
{
	if (na.rm)    x <- x[!is.na(x)]
	n <- length(x)
	# geomean returns a dataframe, convert it to vector
	xbar <- as.numeric(geomean(x))
	if (n < 2L) # 2L is an integer
		return(c(Mean = xbar, Lower = NA, Upper = NA))
	z <- unlist(lapply(seq_len(B), function(i, x, N) sum(x[sample.int(N, 
												N, TRUE, NULL)]), x = x, N = n))/n
	quant <- quantile(z, c((1 - conf.int)/2, (1 + conf.int)/2))
	names(quant) <- NULL
	res <- c(Geomean = xbar, Lower = quant[1L], Upper = quant[2L])
	if (reps) 
		attr(res, "reps") <- z
	res
}
scal=data.frame("year"=as.numeric(names(tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE),
		"ymax"=tapply(wger$value_std_1979_1994,wger$year,max,na.rm=TRUE),
		"mean"=tapply(wger$value_std_1979_1994,wger$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(wger$value_std_1979_1994,wger$year,geomean,na.rm=TRUE)))


li_cl_boot=tapply(wger$value_std_1979_1994,wger$year,smean.cl.boot)
li_cl_boot_geomean=tapply(wger$value_std_1979_1994,wger$year,sgeomean.cl.boot)
bootscal=data.frame("year"=as.numeric(names(li_cl_boot)),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
		"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
		"ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
		"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),    
		"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
		"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))
# creating a subset with all data (glass_eel_yoy is limited in its timeframe)
datageel=subset(wger,wger$lifestage!="yellow eel")
scalgeel=data.frame(
		"year"=as.numeric(names(tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE),
		"ymax"=	tapply(datageel$value_std_1979_1994,datageel$year,max,na.rm=TRUE),
		"mean"=tapply(datageel$value_std_1979_1994,datageel$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean,na.rm=TRUE))
)
datayellow=subset(wger,wger$lifestage=="yellow eel")
scalyellow=data.frame(
		"year"=as.numeric(names(tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE),
		"ymax"=	tapply(datayellow$value_std_1979_1994,datayellow$year,max,na.rm=TRUE),	
		"mean"=tapply(datayellow$value_std_1979_1994,datayellow$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean,na.rm=TRUE)))
scaldata=wger[,c("year","value_std_1979_1994","value_std","site","lifestage")]
################################################################
# With scaling 2000-2010
##############################################################

scal_2000_2009=data.frame("year"=as.numeric(names(tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE),
		"ymax"=tapply(wger$value_std_2000_2009,wger$year,max,na.rm=TRUE),  
		"mean"=tapply(wger$value_std_2000_2009,wger$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(wger$value_std_2000_2009,wger$year,geomean)))
li_cl_boot=tapply(wger$value_std_2000_2009,wger$year,smean.cl.boot)
bootscal_2000_2009=data.frame("year"=as.numeric(names(li_cl_boot)),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
		"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
		"ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
		"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),
		"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
		"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))

scalgeel_2000_2009=data.frame(
		"year"=as.numeric(names(tapply(datageel$value_std_2000_2009,datageel$year,min))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datageel$value_std_2000_2009,datageel$year,min,na.rm=TRUE),
		"ymax"=	tapply(datageel$value_std_2000_2009,datageel$year,max,na.rm=TRUE),	
		"mean"=tapply(datageel$value_std_2000_2009,datageel$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datageel$value_std_2000_2009,datageel$year,geomean))
)

scalyellow_2000_2009=data.frame(
		"year"=as.numeric(names(tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE),
		"ymax"=	tapply(datayellow$value_std_2000_2009,datayellow$year,max,na.rm=TRUE),	
		"mean"=tapply(datayellow$value_std_2000_2009,datayellow$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datayellow$value_std_2000_2009,datayellow$year,geomean,na.rm=TRUE)))
scaldata_2000_2009=wger[,c("year","value_std_2000_2009","site","lifestage")]

#########################
# for Miran
# exporting the geomeans 
########################
print("simple geomeans for glass eel, asked by Miran")
round(unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean)),3)
print ("simple geomeans for yellow eels")
round(unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean)),3)

########################################
# FIGURE 3 WITHOUT LOG SCALE
# normalscale + geomean+ bootstrap scaled mean and confidence interval
#########################################

# first option, in the following figure the red line represents the geometric means
# and the dots are the bootstrap means
g <- ggplot(scaldata)
g1 <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
		ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
		theme(legend.position = "none")

figure3withoutlogscale <- g1+	scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
x11()
print(figure3withoutlogscale)
dev.off()
save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)

# second option, in the following figure the blue line represents the arithmetic means
# and the dots are the bootstrap geommeans

g <- ggplot(scaldata)
g2 <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
		ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=geomean,ymin=ymin_geomean,ymax=ymax_geomean),size=0.5,colour="black")+
		geom_line(data=scal,aes(x=year,y=mean),colour="#003366",size=1.2)+
		theme(legend.position = "none")

figure3withoutlogscale_opt2 <- g2+scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
x11()
print(figure3withoutlogscale_opt2)
dev.off()
save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)
save_figure("figure3withoutlogscale_opt2",figure3withoutlogscale_opt2,800,600)
# scaldata[scaldata$year>2000&scaldata$value_std>1,]
########################################
# FIGURE 3 WITH LOG SCALE
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

figure3 <- g1+
		scale_y_log10(name="scaled 1979-1994 values log scale",limits=c(0.001,30),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
		#ylab()
		
		scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)
x11()
print(figure3)
save_figure(figname="figure3",figure3,800,600)


figure3bis <- g1+
		scale_y_log10(name="scaled 1979-1994 values log scale",
				limits=c(0.001,30),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)
x11()
print(figure3bis)

save_figure(figname="figure3",figure3,800,600)
save_figure(figname="figure3bis",figure3bis,800,600)

########################################
# FIGURE 3 WITH LOG SCALE {{BLACK}}
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

g <- ggplot(scaldata)
figure3black <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5,show.legend=FALSE)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4,show.legend=FALSE)+
		#ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
		geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
		scale_y_log10(name="percentage of 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
		scale_x_continuous(breaks=c(1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,CY))+
		theme_black()
x11()
print(figure3black)
# {{{{{{{{{{{{{{{{{{{{{{{{{
save_figure(figname="figure3black",figure3black,800,600)

# {{{{{{{{{{{{{{{{{{{{{{{{{
##########################################
## Same graph for presentation but labels are in French
##########################################
#g <- ggplot(scaldata)
#g+geom_point(aes(x=year, y=value_std,colour=site,shape=lifestage),size=1.5,legend=FALSE)+
#		geom_line(aes(x=year, y=value_std,colour=site,lty=lifestage),size=0.4,legend=FALSE)+
#		opts(title="Tendance du recrutement Europeen")+
#		#ylab("scaled 1979-1994 values")+
#		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
#		scale_y_log10(name="% de 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
#		scale_x_continuous(name="Annee",breaks=c(1930,1950,1970,1980,1990,2000,2010),
#				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,2010))+theme_dark()
########################################
# FIGURE 4 
# limited graph with scale
########################################
scallog <- scal
scallog[scallog$ymin<1e-2,"ymin"] <- 1e-2
scallog[scallog$ymax>30,"ymax"] <- 30
g <- ggplot(scallog)
figure4 <- g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey",data=scallog)+
		ylab("scaled 1979-1994 values log scale")+
		geom_line(aes(x=year,y=mean),data=scalgeel,colour="darkblue",size=1)+
		geom_line(aes(x=year,y=mean),data=scalyellow,colour="darkorange4",size = 1)+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		scale_y_log10(limits=c(0.01,30),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+
		annotate("rect",xmin=1930,ymin=0.01,xmax=1960,ymax=30,fill="white",alpha=0.7)+
		scale_x_continuous(limits=c(1930,CY))
x11()
print(figure4)
save_figure(figname="figure4",figure4,800,600)

########################################
# FIGURE 4 
# BUT WITH REFERENCE 2000-2010 !
########################################
scallog <- scal_2000_2009
scallog[scallog$ymin<1e-1,"ymin"] <- 1e-1
scallog[scallog$ymax>1000,"ymax"] <- 1000
g <- ggplot(scallog)
figure42000_2009 <- g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey")+
		#ggtitle("Recruitment European overview")+
		ylab("scaled to 2000-2010, log scale")+
		geom_line(aes(x=year,y=mean),data=scalgeel_2000_2009,colour="darkblue",size=1)+
		geom_line(aes(x=year,y=mean),data=scalyellow_2000_2009,colour="darkorange4",size = 1)+
		geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		geom_abline( intercept = 0,slope=0,	alpha = .4,col="red")+
		geom_abline( intercept = 2,slope=0,	alpha = .4,col="red")+
		scale_y_log10(limits=c(1e-1,1000),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+		
		scale_x_continuous(limits=c(1930,CY))+
		annotate("rect",xmin=1930,ymin=1e-1,xmax=1960,ymax=1000,fill="white",alpha=0.7)+
		annotate("rect", xmin = 2000, xmax = 2009, ymin = 0.3, ymax = 3,
				alpha = .2,fill="blue")

x11()
print(figure42000_2009)

save_figure(figname="figure4_2000_2009",figure42000_2009,800,600)

########################################
# FIGURE NOTHING 
# JUST TO CHECK 
########################################
x11()
xg <- unlist(tapply(datageel$value_std,datageel$year,geomean))
rxg <- as.numeric(names(xg))
xy <- unlist(tapply(datayellow$value_std,datayellow$year,geomean))
rxy <- as.numeric(names(xy))
plot(rxg,
		xg,
		type="b",
		main="a simple graph to check that ggplot's running fine")
points(rxy,xy,type="l",col="green")
legend("topright",legend=c("glass","yellow"),col=c("black","green"),lty=1)

# additional figure to check log scaled
x11()
plot(rxy,
		xy,log="y",
		type="b",col="green")
points(rxg,xg,type="l")
#tapply(wger$value_std,wger$year,mean_cl_boot)


########################################
# Figure to put forward recent changes in the series
# WITH REFERENCE 2000-2010 !
########################################
figure_check_one_series <- function(site='KatwG',limits=c(1900,CY)){
	g <- ggplot(scaldata_2000_2009)
	g <- g+geom_point(aes(x=year, y=value_std_2000_2009),col="grey",size=1.5)+
			geom_line(aes(x=year, y=value_std_2000_2009),col="grey",size=0.4)+
			geom_point(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
			geom_line(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
			ylab("scaled 2000-2009 values")+
			geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
			geom_line(data=scal_2000_2009,aes(x=year,y=geomean),colour="red",size=1.2)+
			theme(legend.position = "none")+
			scale_x_continuous(limits=limits,breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata_2000_2009$year),to=max(scaldata_2000_2009$year),by=2))+
			scale_y_continuous(limits=c(0,20))+
			annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
	return(g)
}

figure_check_one_series("KatwG",limits=c(1960,2019))
```



```{r model_for_glass_eel_and_yellow_eel_datasets, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}

glass_eel_yoy$site <- as.factor(glass_eel_yoy$site)

model_ge_area=glm(value_std~year_f:area+site,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log), maxit=300)

# lesser fit :
#model_ge_area1=glm(value_std~year_f:area + as.factor(lfs_code),
#		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
#		family=Gamma(link=log), maxit=300)

print("Analysis for glass eel")
print("data available")
(area_year=table(glass_eel_yoy$year,glass_eel_yoy$area))
print("number of sites finally selected for glass eel glm")
vv$modelge <- list()
vv$modelge$site <- as.character(model_ge_area$xlevels$site)
(vv$modelge$nbsite <- length(vv$modelge$site))
vv$modelge$excluded <- unique(glass_eel_yoy$site)[!unique(glass_eel_yoy$site)%in%vv$modelge$site]
vv$modelge$value_excluded_zero <- glass_eel_yoy[glass_eel_yoy$value==0&!is.na(glass_eel_yoy$value),
		c("value_std","site","year","lifestage","das_comment","area")]


model_older=glm(value_std~year_f+as.factor(site),data=older,family=Gamma(link=log),
		subset=older$value>0 & older$year>1949  ,maxit=300)
vv$model_older <- list()
vv$model_older$site <- as.numeric(as.character(model_older$xlevels$`as.factor(site)`))
vv$model_older$nbsite <- length(vv$model_older$site)
vv$model_older$excluded <- unique(older$site)[!unique(older$site)%in%vv$model_older$site]
vv$model_older$excludedsite <- unique(older[older$site%in%vv$model_older$excluded,"site"])
vv$model_older$excludedsite <- unique(older[older$site%in%vv$model_older$excluded,"site"])
vv$model_older$value_excluded_zero <- older[older$value==0,
		c("value_std","site","year","lifestage","das_comment","area")]




model_older_BalticEffet=glm(value_std~year_f:isBaltic+as.factor(site),data=older,family=Gamma(link=log),
		subset=older$value>0 & older$year>1949  ,maxit=300)
vv$modelolder_BalticEffet <- list()
vv$modelolder_BalticEffet$site <- as.numeric(as.character(model_older_BalticEffet$xlevels$`as.factor(site)`))
vv$modelolder_BalticEffet$nbsite <- length(vv$modelolder_BalticEffet$site)
vv$modelolder_BalticEffet$excluded <- unique(older$site)[!unique(older$site)%in%vv$modelolder_BalticEffet$site]
vv$modelolder_BalticEffet$excludedsite <- unique(older[older$site%in%vv$modelolder_BalticEffet$excluded,"site"])
vv$modelolder_BalticEffet$excludedsite <- unique(older[older$site%in%vv$modelolder_BalticEffet$excluded,"site"])
vv$modelolder_BalticEffet$value_excluded_zero <- older[older$value==0,
		c("value_std","site","year","lifestage","das_comment","area")]

xt_a <- xtable(Anova(model_ge_area,test="F"),
		caption=c("Anova for glass eel recruitment model",
				label="table_anova"))

o <- print(xt_a, file = str_c(tabwd,"/table_anova.tex"), 
		table.placement = "htbp",
		caption.placement = "top",
		NA.string = "",
		include.rownames=TRUE,
		tabular.environment="tabularx",
		width="0.8\\textwidth",
		sanitize.colnames.function=function(x){x})	
save(model_ge_area,model_older,model_older_BalticEffet,file=paste0(shinywd,"recruitment_models.Rdata"))
#plot(model_ge_area)
```

```{r mixed_models, echo=FALSE, eval=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}


library(lme4)
# Mixed models are used because there is no independence between series collected at the same site.
# Here we create a new column location to "join" those series and treat the location as a mixed effect in the model.
glass_eel_yoy$location <- as.character(glass_eel_yoy$site)
unique(glass_eel_yoy$location)
adour_id <- grep("Ad", glass_eel_yoy$location); glass_eel_yoy$location[adour_id]
glass_eel_yoy$location[adour_id] <- "Adou"
albufera_id <- grep("Al", glass_eel_yoy$location); glass_eel_yoy$location[albufera_id]
glass_eel_yoy$location[albufera_id] <-"Albu"
minho_id <- grep("Mi", glass_eel_yoy$location); glass_eel_yoy$location[minho_id]
glass_eel_yoy$location[minho_id] <-"Minho"
gironde_id <- grep("Gi", glass_eel_yoy$location); glass_eel_yoy$location[gironde_id]
glass_eel_yoy$location[minho_id] <-"Giro"
brownhill_id <- grep("Bro", glass_eel_yoy$location); glass_eel_yoy$location[brownhill_id]
glass_eel_yoy$location[minho_id] <-"Bro"
flatford_id <- grep("Fla", glass_eel_yoy$location); glass_eel_yoy$location[flatford_id]
glass_eel_yoy$location[minho_id] <-"Fla"

glass_eel_yoy$lfs_code <- as.factor(glass_eel_yoy$lfs_code)
glass_eel_yoy$location <- as.factor(glass_eel_yoy$location)

# glmer is used to fit generalized (non-Gaussian) linear mixed models
glmer1 <- glmer(value_std~year_f:area+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer11 <- glmer(value_std~year_f:area+location+(1|site), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer12 <- glmer(value_std~year_f:area+site+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

# model_ge_area is the glm, compare it with ANOVA, this should be fine since is ML



# The deviance The deviance is basically a measure of how much unexplained variation there is in 
# regression model â the higher the value the less accurate the model
devglmer1 <- -2*logLik(glmer1)
devglm <- -2*logLik(model_ge_area)
# diffence of deviance between the two models
(delta_dev <- as.numeric(devglmer1-devglm))
(delta_df <- attr(devglm,"df")-attr(devglmer1,"df"))
## the GLM has a better fit
cat('Chi-square =', delta_dev, '(df=', delta_df,'), p =', 
		pchisq(delta_dev,delta_df,lower.tail=FALSE), "\n")
# same shown here
anova( glmer1, model_ge_area,  test="Chisq")
# So the glm is better than the mixed model



# Here we compare the mixed structure of the models, so we are using REML

glmer1 <- glmer(value_std~year_f:area+site+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glass_eel_yoy$year2 <- pmax(year,2011)
# model with  lfs_code

glmer2 <- glmer(value_std~year_f:area+(1+year|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer3 <- glmer(value_std~year_f:area+(1+year|location) + (1+year2|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

anova(glmer2, glmer1, refit=FALSE)

save(glmer1, glmer2, glmer3, file=paste0(datawd,glmer.Rdata))
#fixef(glmer1)['(Intercept)'] + ranef(glmer1)$location

```



```{r model_for_glass_eel_graph_and_predictions, fig.show='hide',echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
# 1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~
######################################"
#~glass eel (and elver = glass eel + yellow eel) migrant analysis
######################################"~

########new sets of lines to graph plots with confidence intervals
# using expand.grid to build a complete grid for predictions
dat_ge=expand.grid(year_f=model_ge_area$xlevels$year_f,area=model_ge_area$xlevels$area,
		site=model_ge_area$xlevels$site[1])
dat_ge$year <- as.numeric(as.character(dat_ge$year_f))


#predicting
dat_ge$p=predict(model_ge_area,newdata=dat_ge)
dat_ge$se=predict(model_ge_area,newdata=dat_ge,se.fit=TRUE)[["se.fit"]]



mean_1960_1979 <- aggregate(dat_ge[dat_ge$year<1980,"p"],list(dat_ge[dat_ge$year<1980,"area"]),mean)
names(mean_1960_1979) <- c("area","mean")	



dat_ge <- merge(dat_ge,mean_1960_1979,by="area")
dat_ge$p_std_1960_1979 <- exp(dat_ge$p-dat_ge$mean)
dat_ge$p_std_1960_1979_min <- exp(dat_ge$p-dat_ge$mean-1.96*dat_ge$se)
dat_ge$p_std_1960_1979_max <- exp(dat_ge$p-dat_ge$mean+1.96*dat_ge$se)


upperlimit  <- 5
dat_ge$p_std_1960_1979_maxgraph <- pmin(dat_ge$p_std_1960_1979_max,upperlimit-0.01)

g <- ggplot(dat_ge,aes(x=year,y=p_std_1960_1979))

figure5_without_logscale<- g+
		geom_line(aes(colour=area,lty=area),lwd=1)+ 		
		scale_colour_brewer(name="area",palette="Set1")+
		geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_maxgraph,fill=area),alpha=.3)+
		coord_cartesian(ylim=c(0,5))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position = c(.8, .8))
X11(width=300,height=250)
figure5_without_logscale
save_figure("figure5_without_logscale_ribbon",figure5_without_logscale,600,480)

# function similar to theme_dark() but allows legends
# black and white plot ====
figure5_without_logscale_black <- g+geom_line(aes(colour=area,lty=area),lwd=1)+
		scale_colour_manual(name="area",values=c("yellow","lawngreen"))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_black()+
		geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)+
		scale_fill_manual(name="area",values=c("yellow","lawngreen"))

X11()
figure5_without_logscale_black
save_figure("figure5_without_logscale_black_ribbon",figure5_without_logscale_black,600,480)


#====
#+geom_smooth(aes(ymin = min, ymax = max,fill=area),stat="identity")+facet_grid( ~ area) 
figure5 <- g+geom_line(aes(colour=area,lty=area),lwd=1.3)+geom_point(aes(colour=area,fill=area,shape=area),size=3)+
		#ggtitle("Recruitment overview glass eel series")+
		scale_colour_brewer(name="area",palette="Set1")  +
		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position=c(.8,.9))+geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)

X11()
figure5
save_figure("figure5_ribbon",figure5,600,480)
#figure5danish <- g+geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		ggtitle("title="Glasaal data fra hele Europa")+
#		scale_colour_brewer(name="area",palette="Set1")  +
#		xlab("Aar")+
#		scale_y_log10(name="Linear model forudsigelser/ gennemsnit 1960-1979",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#figure5danish

#levels(dat$area) <- c (
#		iconv("Andre steder i Europa","UTF8"),
#		iconv("Nordsj?en","UTF8"))#
#g <- ggplot(dat,aes(x=year,y=p_std_1960_1979))
#figure5norvegiean <- g+
#		geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,shape=area),size=3)+
#		ggtitle(label=iconv("Indeks av glass?lrekruttering","UTF8"))+
#		scale_colour_brewer(name=iconv("Omr?det","UTF8"),palette="Set1")  +
#		scale_shape(name=iconv("Omr?det","UTF8"))+
#		scale_linetype(name=iconv("Omr?det","UTF8"))+
#		xlab(iconv("?r","UTF8"))+
#		scale_y_log10(name=iconv("Standardiserte GLM-prognoser (i prosent av
#		1960-1979-gjennomsnitt)","UTF8"), #limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#save_figure("figure5norvegiean",figure5norvegiean,600,480)
#pdf("images/2013/figure5norvegiean.png")
#figure5norvegiean
#dev.off()
save_figure("figure5_ribbon",figure5,600,480)



#figure5bw <- g+geom_line(aes(colour=area,lty=area),wd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		#ggtitle("Recruitment overview glass eel series")+
#		scale_colour_manual(name="area",values=c("black","grey40"))  +
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
#		scale_y_log10(name="standardized glm predictions \n mean 1960-1979-log scale",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))+
#		theme_bw()+
#		theme(legend.box =NULL,
#				legend.key = element_rect(colour = NA, fill = 'white'),
#				legend.text = element_text(size = 8, colour = 'black'), 
#				legend.background = element_rect(colour = NA, fill = 'white'))
#print(figure5bw)
#save_figure("figure5bw",figure5bw,600,480)


pred <- dcast(dat_ge,year~area,value.var="p_std_1960_1979")
predmin <- dcast(dat_ge,year~area,value.var="p_std_1960_1979_min")	
predmax <- dcast(dat_ge,year~area,value.var="p_std_1960_1979_max")
synthesis <- cbind(pred,predmin[,c(2,3)],predmax[,c(2,3)])
colnames(synthesis) <- c("year","Elsewhere Europe","North Sea", "EEminCI","NSminCI","EEmaxCI","NSmaxCI")

#if (opt_calculation=="geomean") {
#	synthesis=as.data.frame(tapply(dat_ge[,"p_std_1960_1979"],
#					list(dat_ge[,"year_f"],dat_ge[,"area"]),
#					function(X) {Y=geomean(X) ;
#						return(as.numeric(Y))}))
#} else {
#	synthesis=as.data.frame(tapply(dat_ge[,"p_std_1960_1979"],
#					list(dat_ge[,"year_f"],dat_ge[,"area"]),mean,na.rm=TRUE))
#}
vv$five_year_average <- synthesis %>% filter(year>CY-5) %>% dplyr::select(c(1,2,3)) %>% colMeans() %>% round(digits=3)
vv$five_year_averagem3 <- synthesis %>% filter(year<=CY-2,year>CY-7) %>% dplyr::select(c(1,2,3)) %>% colMeans() %>% round(digits=3)

#xfive_year_avg_glass <- xtable(x = five_year_avg_glass,
#		label = "table_five_year_avg_glass",
#		caption = str_c("GLM estimates for glass eel series, averaged every five years"))
#print(xfive_year_avg_glass, 
#		file = str_c(tabwd,"/table_five_year_avg_glass.tex"),
#		table.placement = "htbp",
#		caption.placement = "top", 
#		NA.string = ".")




gg0 <- synthesis[,c("Elsewhere Europe","North Sea")]
colnames(gg0) <- c("EE","NS")
rownames(gg0) <- synthesis$year
gg <- split_per_decade_ge(gg0)
gg[,1:8] <- 100*round(gg[,1:8],2)
gg[,9:ncol(gg)] <- 100*round(gg[,9:ncol(gg)],3)
nothing <- latex(gg,
		rowlabel="",
		rowlabel.just="c",
		where="hptb",
		cgroup=cgroupdecade,
		n.cgroup=rep(ncol(gg0),length(cgroupdecade)),
		collabel.just=strsplit("c c c c c c c c c c c c c c c", " ")[[1]],	
		col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
		#landscape=TRUE,
		label="table_glm_glass_eel",
		caption=str_c("GLM $glass~eel \\sim year:area + site $ geometric means of predicted values for ",vv$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period."),	
		file= str_c(tabwd,"/table_glm_glass_eel.tex"))



write.table(synthesis,file=str_c(datawd,"glm_results_glass.csv"),sep=";")

#plot(log(synthesis[synthesis$year>1979,"Elsewhere Europe"]))
trend <- synthesis[synthesis$year>1979,]
trend$EE <- trend$"Elsewhere Europe"
trend$lEE <- log(trend$EE)

trend$lNS <- log(trend$"North Sea")


#round(lm(lEE~year,data=trend)$coefficient[2],4) # -0.098
#round(lm(lNS~year,data=trend)$coefficient[2],4) # -0.098 North Sea -0129

# sgipee test for change ee ---------------------------------------------

#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
#sgipee_test_for_change_ee <- summary(test1)$coefficients[3,4]
#if (sgipee_test_for_change_ee<=0.05) {
#  test_sgipee_char_ee <- "significant"
#}else {
#  test_sgipee_char_ee <- "not significant"
#}

## test on the trend after 2011 ee ----------------------------------------------
#
#K = matrix(c(0,1,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
#summary_coefficient_after <- summary(glht(test1, linfct = K, alternative="greater"))
#confint_coefficient_after  <- confint(glht(test1, linfct = K, alternative="greater"))
#trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)


# sgipee test for change ns ---------------------------------------------

#test=lm(lNS~year+pmax(year,2011),data=trend)
#
#sgipee_test_for_change_ns <- summary(test)$coefficients[3,4]
#if (sgipee_test_for_change_ns<=0.05) {
#  test_sgipee_char_ns <- "significant"
#}else {
#  test_sgipee_char_ns <- "not significant"
#}

## test on the trend after 2011 ns ----------------------------------------------
#
#
#summary_coefficient_after <- summary(glht(test, linfct = K, alternative="greater"))
#confint_coefficient_after  <- confint(glht(test, linfct = K, alternative="greater"))
#trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)


# test glm with a breakpoint ----------------------------------------------------
# this models takes numeric, not factors we assume a log trend
model_ge_area_b=glm(value_std~year:area+site+pmax(year,2011):area,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>=1980,],
		family=Gamma(link=log), maxit=300)
##summary(model_ge_area_b)
## plot(model_ge_area_b)
len <- length(coef(model_ge_area_b))
#gg <- visreg::visreg(model_ge_area_b,"year",by="area", plot=TRUE,gg=TRUE,band=FALSE)
#gg <- gg+facet_wrap(~area,scales="free_y")
#print(gg)
# last coeff are
# year:areaElsewhere Europe 
# year:areaNorth Sea 
# areaElsewhere Europe:pmax(year, 2011)   
# areaNorth Sea:pmax(year, 2011) 
#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
# this is the n-1 row of the summary
sgipee_test_for_change_ee <- summary(model_ge_area_b)$coefficients[len-1,4]   
sgipee_test_for_change_ns <- summary(model_ge_area_b)$coefficients[len,4]

Kee = matrix(c(rep(0,len-4),1,0,1,0), nrow = 1) # we just add the to coef trend to have the trend after 2011
# test if the coefficient alpha + beta > 0 so the slope of increase is larger than 0
# H0 alpha+beta = 0.5 / alternative alpha+beta >0
summary_coefficient_afteree <-  summary(glht(model_ge_area_b, linfct = Kee, alternative="greater",rhs=0)) 
# test if the coefficient alpha + beta > 0.05 so the slope of the increase is larger than the slope of decrease
# H0 alpha+beta = 0.5 / alternative alpha+beta >0.5
summary(glht(model_ge_area_b, linfct = Kee, alternative="less",rhs=0.05))
Kns = matrix(c(rep(0,len-4),0,1,0,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
summary_coefficient_afterns <- summary(glht(model_ge_area_b, linfct = Kns, alternative="greater"))
trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afteree$test$coefficients,
		summary_coefficient_afteree$test$pvalues)
trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afterns$test$coefficients,
		summary_coefficient_afterns$test$pvalues)


# back to long format, save for shiny

save(dat_ge, file=str_c(datawd,"dat_ge.Rdata"))
save(dat_ge, file=str_c(shinywd,"dat_ge.Rdata"))
```

```{r segmented_regression, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
if(!require(segmented)) install.packages("segmented") ; require(segmented)


dat_ge1 <- expand.grid(year=1980:2025,area=as.factor(model_ge_area_b$xlevels$area),
		site=model_ge_area_b$xlevels$site[1])

dat_ge1$p <- predict(model_ge_area_b,newdata=dat_ge1)
dat_ge1$se <- predict(model_ge_area_b,newdata=dat_ge1,se.fit=TRUE)[["se.fit"]]

#mean_1960_1979 # this is the average p for all series before 1980
# it was generated in the previous chunk
dat_ge1 <- merge(dat_ge1, mean_1960_1979, by="area")

dat_ge1$p_std_1960_1979=exp((dat_ge1$p-dat_ge1$mean))
dat_ge1$p_std_1960_1979_min=exp(dat_ge1$p-dat_ge1$mean-1.96*dat_ge1$se)
dat_ge1$p_std_1960_1979_max=exp(dat_ge1$p-dat_ge1$mean+1.96*dat_ge1$se)






figure51 <-  
		ggplot(dat_ge,aes(x=year,y=p_std_1960_1979))+
		geom_line(aes(colour=area,lty=area),lwd=1.3)+
		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
		geom_line(data=dat_ge1, aes(x=year,y=p_std_1960_1979,colour=area))+
		#ggtitle("Recruitment overview glass eel series")+
		scale_colour_brewer(name="area",palette="Set1")  +
		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position=c(.8,.9))+geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)


ggplot(dat_ge1) 

datNS <- dat_ge %>%filter(area=="North Sea") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datNS)
o1<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011,2014)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o1)
datEE <- dat_ge %>%filter(area=="Elsewhere Europe") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datEE)
o2<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011,2014)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 500, display=TRUE))
plot(o2)

datNS <- dat_ge %>%filter(area=="North Sea") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datNS)
o11 <- segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o11)
datEE <- dat_ge %>%filter(area=="Elsewhere Europe") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datEE)
o21<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o21)
AIC(o1, o11, o2, o21)
```

```{r model_diagnostics, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#####deprecated
# summary(model_ge_area)
# influence_plot
require(boot)
gey <- glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959&!is.na(glass_eel_yoy$value_std),]
gey$E <- resid(model_ge_area) # working residuals
gey$P=predict(model_ge_area)
plot(coefficients(model_ge_area)[grep("North Sea",names(coefficients(model_ge_area)))],type="l")
points(log(datNS$p_std_1960_1979)+4,type="l",col="red")
plot(gey$E~gey$P)

# Three ways of getting the diagnostic graph of residuals
glm.diag.plots(model_ge_area)
plot(model_ge_area,which=1)
panel.smooth(gey$P,gey$E,col="black",col.smooth="red")
library(lattice)
panel.smoother <- function(x, y) {
	panel.xyplot(x, y) # show points 
	panel.loess(x, y,col.line="red")  # show smoothed line 
	panel.abline(h=0)
}
panel.smoother2 <- function(x, y) {
	panel.xyplot(x, y) # show points 
	panel.loess(x, y,col.line="red")  # show smoothed line 
	panel.abline(h=-0.2)
}
mga_diag <- glm.diag(model_ge_area)
gey$res <- mga_diag$res
show.settings()

xyplot(res~P, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
xyplot(res~year, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother2,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
abline(h=0)
xyplot(res~P|area, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
xyplot(res~P|site, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
# un rï¿½sidu / carte par annee


# pour aller chercher les stations en 3035
options(sqldf.RPostgreSQL.user = cred$user,  
			sqldf.RPostgreSQL.password = passwordwgeel,
			sqldf.RPostgreSQL.dbname = cred$dbname,
			sqldf.RPostgreSQL.host = cred$host, #getInformation("PostgreSQL host: if local ==> localhost"), 
			sqldf.RPostgreSQL.port = cred$port)
locxy_3035 <- sqldf("select ser_id,st_x(the_geom) as X, st_y(the_geom) as Y from ts.t_location_loc where loc_tyl_code='Recruit'")
gey <- merge(gey,locxy_3035,by="ser_id",all.x=TRUE,all.y=FALSE)
Gey <- gey #spatial data frame
coordinates(Gey) <- c("x","y")
# dev.size("px") to check right dimensions
#png(file=str_c(imgwd,"/resid_bretagne.png"), width=672,height= 389)

#bb <- elargit(bb,0.01,0.01)

#frequire(latticeExtra) # a + as.layer(b) pour mettre deux graphiques
# but for now I don't have missing data there
emu_c=readShapePoints(str_c(shpwd,"/","t_emuagreg_ema_point_3035.shp")) # a spatial object of class sp
# this corresponds to the center of each emu.
wisesp=readShapePoly(str_c(shpwd,"/","rbd_f1v3_3035.shp")) # a spatial object of class sp
# this is the map showing the "missing parts", to be placed behind the others
country_c=readShapePoints(str_c(shpwd,"/","t_country_coun_3035"))# a spatial object of class sp
# this is the map of coutry centers, to overlay points for each country
emusp0=readShapePoly(str_c(shpwd,"/","t_emuagreg_ema_3035")) # a spatial object of class sp
years <- 1960:2019
bb <- bbox(emusp0)
# loop to create all the graphs
for (year in years){
	#trellis.device(device="png",filename=str_c(imgwd,"/resids/",year,".png"))
	png(filename=str_c(imgwd,"/resids/",year,".png"),width=600, height=500)
	bb <- bubble(Gey[Gey@data$year==year,], "E",col=c("red","green"),main=str_c(year),
			xlab="",ylab="",
			do.sqrt = FALSE,
			sp.layout=list("sp.polygons", emusp0,    first = FALSE)
	) 		
	print(bb)
	dev.off()
}
# 
model_ge_area <- gls(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
		subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959 ,maxit=300)

lmer(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
		subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959)

#library(nlme)
glass_eel_yoy$lvalue_std=log(glass_eel_yoy$value_std)
M.lm <- gls(lvalue_std~site,data=glass_eel_yoy)

vf1Fixed <- 
		
		M.gls1  <- glmmPQL(value_std~year_f:area+site,
				data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
				random = ~ 1 | site,
				weights = varIdent (form = ~ 1 | site) ,
				family=Gamma(link=log)
		)
M.gls1  <- glmmPQL(value_std~year_f:area+site,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		random = ~ 1 | site,
		family=Gamma(link=log)
)
# prediction for lough neagh
# historical data
#glass_eel_yoy2=wger[wger$lifestage!="yellow eel" ,] #glass eel and yoy
#model_ge_area2=glm(value_std~year_f:area+site,data=glass_eel_yoy2[glass_eel_yoy2$value>0 ,],
#	family=Gamma(link=log), maxit=300)
#
#newdata <- expand.grid(year_f=levels(glass_eel_yoy2$year_f),site="Bann",area="Elsewhere Europe")
#newdata <- newdata[as.numeric(as.character(newdata$year_f))>1922,]
#newdata$P=predict(model_ge_area2,type="response",newdata=newdata)
#newdata$year <- as.numeric(as.character(newdata$year_f))
#
#plot(newdata$year,newdata$P, type="b",col="black",xlab="year",ylab="standardized value")
#gey2 <- glass_eel_yoy2[glass_eel_yoy2$site=='Bann',]
#gey2 <- gey2[order(gey2$year),]
#points(gey2$year,gey2$value_std, type="b",col="grey40",lty=2,pch=18)
#legend("topright",col=c("black","grey20"),lty=c(1,2),pch=c(1,18),legend=c("predicted for Bann","Bann (observed)"))
#write.table(gey2,file=str_c(datawd,"Bann_data.csv"),sep=";")
#write.table(newdata,file=str_c(datawd,"Bann_predictions.csv"),sep=";")
```

```{r model_for_yellow_eel, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~
######################################"
#~yellow eel migrant analysis
######################################"~
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~~

print("Analysis for yellow eel")
area_year_older=table(older$year,older$area)
vv$nb_for_yellow_eel_glm <- length(unique(older$site))
table(older$geo)
print("stations selected for analysis")
unique(older$site)
model_older=glm(value_std ~ year_f + as.factor(site),
		data = older,
		family = Gamma(link=log),
		subset = older$value >0 &
				older$year > 1949 & older$year <=CY-1,
		maxit = 300)
# parteen was removed but is no longer among the series
summary(model_older)
#plot(model_older)
anova(model_older,test="F")


dat_ye=expand.grid(year_f=unique(model_older$xlevels$year_f),
		site=model_older$xlevels$`as.factor(site`[1])
dat_ye$year=as.numeric(as.character(dat_ye$year))

#predicting --------------------------------------------------------------------------------------------

# in the log scale
dat_ye$p=predict(model_older,newdata=dat_ye)
dat_ye$se=predict(model_older,newdata=dat_ye,se.fit = TRUE)$se.fit

#standardising prediction to 1960-1979 level -----------------------------------------------------------
# 2 options mean or geomean


#in the logscale we remove the arithmetic mean to standardise prediction relatively to
#1960-1980 
dat_ye$mean_1960_1979=mean(dat_ye[dat_ye$year>=1960&dat_ye$year<1980,"p"])
dat_ye$value_std_1960_1979=exp(dat_ye$p-dat_ye$mean_1960_1979)
dat_ye$yellow_eel_min=exp(dat_ye$p-dat_ye$mean-1.96*dat_ye$se)
dat_ye$yellow_eel_max=exp(dat_ye$p-dat_ye$mean+1.96*dat_ye$se)

# Table --------------------------------------------------------------------------------------------

yy0 <- dat_ye[,"value_std_1960_1979",drop = FALSE]
rownames(yy0) <- dat_ye$year

yy <- split_per_decade(data=yy0)
yy <- 100*round(yy,2)
nothing <- latex(yy,
		rowlabel="",
		rowlabel.just="c",
		where="hptb",
		col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
		landscape=FALSE,
		label="table_glm_yellow",
		caption=str_c("GLM $yellow~eel \\sim year + site $ geometric means of predicted values for ",vv$nb_series_older, " yellow eel series, values given in percentage of the 1960-1979 period."),	
		file= str_c(tabwd,"/table_glm_yellow.tex"))

# Figures -------------------------------------------------------------------------------------------


dat_ye$time =as.Date(strptime(paste(dat_ye$year,"-01-01",sep=""),format="%Y-%m-%d"))
g <- ggplot(dat_ye,aes(x=time,y=value_std_1960_1979)) 
figure6_without_log_scale <- g+ geom_line(lwd=1, color="darkolivegreen")+ geom_point(color="khaki3")+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+	
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.6,fill="darkolivegreen2")+
		xlab("year")+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))#+
#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="grey20")
save_figure("figure6_without_log_scale",figure6_without_log_scale,600,480)
figure6_without_log_scale
figure6_without_log_scale_black <- g+geom_line(lwd=1,color="white")+ 
		geom_point(color="white")+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.3,fill="darkolivegreen2")+
		#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="turquoise1") +
		theme_black()
figure6_without_log_scale_black
save_figure("figure6_without_log_scale_black",figure6_without_log_scale_black,600,480)
figure6 <- g+geom_line(lwd=1,color="darkolivegreen")+geom_point(color="khaki3")+
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' (log scale)'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%")) +
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.3,fill="darkolivegreen2")+
		xlab("year")+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))
#stat_smooth(method="lm",formula=y ~ ns(x,4), lty=2, size=0.8,alpha=0.3,col="grey20")
figure6
save_figure("figure6",figure6,600,480)

# Final save ----------------------------------------------------------------------------------------

write.table(synthesis,file=str_c(datawd,"glm_results_yellow.csv"),sep=";")
dat_ye <- dat_ye[,c("year","p","se","mean_1960_1979","yellow_eel_min","yellow_eel_max","value_std_1960_1979")]
vv$five_year_averagey <- dat_ye %>% filter(year>CY-5) %>% dplyr::select(c(year,value_std_1960_1979)) %>% colMeans() %>% round(digits=3)
vv$dat_ye <- 
		dat_ye %>% 
		filter(year<=CY-2,year>CY-7) %>% 
		dplyr::select(c(year,value_std_1960_1979)) %>% 
		colMeans() %>% 
		round(digits=3)


#colnames(dat_ye)  <- c("year","geomean_p_std_1960_1979") 
save(dat_ye,file=paste0(datawd,"dat_ye.Rdata")) 
save(dat_ye,file=paste0(shinywd,"dat_ye.Rdata")) 

if (file.exists(str_c(datawd,"glm_results_glass_and_yellow.xlsx"))) unlink(str_c(datawd,"glm_results_glass_and_yellow.xlsx"))
openxlsx::write.xlsx(x=list("Glass eel"=data.frame(
						"year"=synthesis$year,
						"EE_minCI_percent"=100*synthesis$EEminCI,
						"EE_percent"=100*synthesis$"Elsewhere Europe",
						"EE_maxCI_percent"=100*synthesis$EEmaxCI,
						"NS_minCI_percent"=100*synthesis$NSminCI,
						"NS_percent"=100*synthesis$"North Sea",
						"NS_maxCI_percent"=100*synthesis$NSmaxCI
				), "Yellow eel"= data.frame("year"=dat_ye$year,
						"Y_minCI_percent"=100*dat_ye$yellow_eel_min,
						"Y_percent"=100*dat_ye$value_std_1960_1979,
						"Y_maxCI_percent"=100*dat_ye$yellow_eel_max)),
		file=str_c(datawd,"glm_results_glass_and_yellow.xlsx"),
		row.names=FALSE)


# saving yellow_eel_pred for shiny ---------------------------------------------------------------------
yellow_eel_pred <- dat_ye

save(yellow_eel_pred,file=paste0(datawd,"yellow_eel_pred.Rdata"))
save(yellow_eel_pred,file=paste0(shinywd,"yellow_eel_pred.Rdata"))
```

```{r model_for_yellow_eel_baltic_effect, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~
######################################"
#~yellow eel migrant analysis
######################################"~
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~~

print("Analysis for yellow eel")
area_year_older=table(older$year,older$area)
vv$nb_for_yellow_eel_glm <- length(unique(older$site))
table(older$geo)
print("stations selected for analysis")
unique(older$site)
model_older_BalticEffect=glm(value_std ~ year_f:isBaltic + as.factor(site),
		data = older,
		family = Gamma(link=log),
		subset = older$value >0 &
				older$year > 1949 & older$year <=CY-1,
		maxit = 300)
# parteen was removed but is no longer among the series
summary(model_older_BalticEffect)
#plot(model_older)
anova(model_older_BalticEffect,test="F")


dat_ye_BalticEffect=expand.grid(year_f=unique(model_older$xlevels$year_f),isBaltic=c(TRUE,FALSE),
		site=model_older_BalticEffect$xlevels$`as.factor(site`[1])
dat_ye_BalticEffect$year=as.numeric(as.character(dat_ye_BalticEffect$year))

#predicting --------------------------------------------------------------------------------------------

# in the log scale
dat_ye_BalticEffect$p=predict(model_older_BalticEffect,newdata=dat_ye_BalticEffect)
dat_ye_BalticEffect$se=predict(model_older_BalticEffect,newdata=dat_ye_BalticEffect,se.fit = TRUE)$se.fit

#standardising prediction to 1960-1979 level -----------------------------------------------------------
# 2 options mean or geomean


#in the logscale we remove the arithmetic mean to standardise prediction relatively to
#1960-1980 
means_per_area <- dat_ye_BalticEffect %>%
  filter(year>=1960 & year<1980)%>%
  group_by(isBaltic) %>%
  summarise(ref=mean(p))
  

dat_ye_BalticEffect <- merge(dat_ye_BalticEffect, means_per_area) 
dat_ye_BalticEffect$value_std_1960_1979=exp(dat_ye_BalticEffect$p-dat_ye_BalticEffect$ref)
dat_ye_BalticEffect$yellow_eel_min=exp(dat_ye_BalticEffect$p-dat_ye_BalticEffect$ref-1.96*dat_ye_BalticEffect$se)
dat_ye_BalticEffect$yellow_eel_max=exp(dat_ye_BalticEffect$p-dat_ye_BalticEffect$ref+1.96*dat_ye_BalticEffect$se)

# Table --------------------------------------------------------------------------------------------

yy0_BalticEffect <- dat_ye_BalticEffect %>%
  dplyr::select(isBaltic,"value_std_1960_1979",year) %>%
  tidyr::pivot_wider(id_cols=year,names_from=isBaltic,values_from=value_std_1960_1979) %>%
  tibble::column_to_rownames("year") %>%
  dplyr::rename(Baltic=`TRUE`, Outside = `FALSE`)

yy_BalticEffect <- split_per_decade_ge(data=yy0_BalticEffect)
yy_BalticEffect <- 100*round(yy_BalticEffect,2)
nothing <- latex(yy,
		rowlabel="",
		rowlabel.just="c",
		where="hptb",
		col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
		landscape=FALSE,
		label="table_glm_yellow",
		caption=str_c("GLM $yellow~eel \\sim year + site $ geometric means of predicted values for ",vv$nb_series_older, " yellow eel series, values given in percentage of the 1960-1979 period."),	
		file= str_c(tabwd,"/table_glm_yellow.tex"))

# Figures -------------------------------------------------------------------------------------------


dat_ye_BalticEffect$time =as.Date(strptime(paste(dat_ye$year,"-01-01",sep=""),format="%Y-%m-%d"))
g <- ggplot(dat_ye_BalticEffect,aes(x=time,y=value_std_1960_1979, fill=isBaltic)) 
figure6_without_log_scale_BalticEffect <- g+ geom_line(aes(color=isBaltic),lwd=1)+ geom_point(aes(color=isBaltic))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+	
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max,fill=isBaltic),alpha=.6)+
		xlab("year")+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))#+
#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="grey20")
save_figure("figure6_without_log_scale_BalticEffect",figure6_without_log_scale_BalticEffect,600,480)
figure6_without_log_scale_BalticEffect
figure6_without_log_scale_black_BalticEffect <- g+geom_line(lwd=1,color="white")+ 
		geom_point(color="white")+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max,fill=isBaltic),alpha=.3)+
		#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="turquoise1") +
		theme_black()
figure6_without_log_scale_black
save_figure("figure6_without_log_scale_black_BalticEffect",figure6_without_log_scale_black_BalticEffect,600,480)
figure6_BalticEffect <- g+geom_line(aes(color=isBaltic),lwd=1)+geom_point(aes(color=isBaltic))+
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' (log scale)'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%")) +
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max,fill=isBaltic),alpha=.3)+
		xlab("year")+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))
#stat_smooth(method="lm",formula=y ~ ns(x,4), lty=2, size=0.8,alpha=0.3,col="grey20")
figure6_BalticEffect
save_figure("figure6_BalticEffect",figure6_BalticEffect,600,480)

# Final save ----------------------------------------------------------------------------------------

write.table(synthesis,file=str_c(datawd,"glm_results_yellow.csv"),sep=";")
dat_ye_BalticEffect <- dat_ye_BalticEffect[,c("isBaltic","year","p","se","ref","yellow_eel_min","yellow_eel_max","value_std_1960_1979")]
vv$five_year_averagey_BalticEffect <- dat_ye_BalticEffect %>% filter(year>CY-5) %>% dplyr::select(c(year,value_std_1960_1979)) %>% colMeans() %>% round(digits=3)
vv$dat_ye_BalticEffect <- 
		dat_ye_BalticEffect %>% 
		filter(year<=CY-2,year>CY-7) %>% 
		dplyr::select(c(year,value_std_1960_1979)) %>% 
		colMeans() %>% 
		round(digits=3)


#colnames(dat_ye)  <- c("year","geomean_p_std_1960_1979") 
save(dat_ye_BalticEffect,file=paste0(datawd,"dat_ye_BalticEffect.Rdata")) 
save(dat_ye_BalticEffect,file=paste0(shinywd,"dat_ye_BalticEffect.Rdata")) 

synthesis_Baltic <- dat_ye_BalticEffect %>%
  dplyr::select(year,isBaltic,value_std_1960_1979,yellow_eel_min,yellow_eel_max) %>%
  tidyr::pivot_wider(id_cols=year,names_from=isBaltic, values_from=c(value_std_1960_1979,yellow_eel_min,yellow_eel_max))

if (file.exists(str_c(datawd,"glm_results_glass_and_yellow.xlsx"))) unlink(str_c(datawd,"glm_results_glass_and_yellow.xlsx"))
openxlsx::write.xlsx(x=list("Glass eel"=data.frame(
						"year"=synthesis$year,
						"EE_minCI_percent"=100*synthesis$EEminCI,
						"EE_percent"=100*synthesis$"Elsewhere Europe",
						"EE_maxCI_percent"=100*synthesis$EEmaxCI,
						"NS_minCI_percent"=100*synthesis$NSminCI,
						"NS_percent"=100*synthesis$"North Sea",
						"NS_maxCI_percent"=100*synthesis$NSmaxCI
				), "Yellow eel"= data.frame("year"=dat_ye$year,
						"Y_minCI_percent"=100*dat_ye$yellow_eel_min,
						"Y_percent"=100*dat_ye$value_std_1960_1979,
						"Y_maxCI_percent"=100*dat_ye$yellow_eel_max),
				"Yellow eel Baltic Effect"=data.frame(
						"year"=synthesis_Baltic$year,
						"Baltic_minCI_percent"=100*synthesis_Baltic$yellow_eel_min_FALSE,
						"Baltic_percent"=100*synthesis_Baltic$value_std_1960_1979_FALSE,
						"Baltic_minCI_percent"=100*synthesis_Baltic$yellow_eel_max_FALSE,
						"Outside_minCI_percent"=100*synthesis_Baltic$yellow_eel_min_FALSE,
						"Outside_percent"=100*synthesis_Baltic$value_std_1960_1979_FALSE,
						"Outside_minCI_percent"=100*synthesis_Baltic$yellow_eel_max_FALSE
				)),
		file=str_c(datawd,"glm_results_glass_and_yellow.xlsx"),
		row.names=FALSE)


# saving yellow_eel_pred for shiny ---------------------------------------------------------------------
yellow_eel_pred <- dat_ye
yellow_eel_pred_BalticEffect <- dat_ye_BalticEffect

save(yellow_eel_pred,yellow_eel_pred_BalticEffect,file=paste0(datawd,"yellow_eel_pred.Rdata"))
save(yellow_eel_pred,yellow_eel_pred_BalticEffect,file=paste0(shinywd,"yellow_eel_pred.Rdata"))
```


```{r test_period, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


glass_eel_yoy$site <- as.factor(glass_eel_yoy$site)
# we select all series that are already included (removed -1)

load(file=str_c(shinywd,"inclusion.Rdata"))
# todo redo this too tired now
inner_join(glass_eel_yoy, 
				inclusion %>% filter(sgl_year!=-1), 
				by=(c("ser_id"="sgl_ser_id"))) %>%
		dplyr::select(sgl_year,area,site)%>%
		distinct() %>%
		mutate(number=1)%>%
		dplyr::select(-site)%>% 
		group_by(sgl_year,area)%>%
		mutate(number=sum(number))
#unique(glass_eel_yoy$ser_id)[!unique(glass_eel_yoy$ser_id)%in%inclusion$sgl_ser_id  ]
run_exclude_before <- function(the_year){
	load(file=str_c(datawd,"dat_ge.Rdata"))
	dat_ge_reference <- dat_ge
	glass_eel_yoy_included <- inner_join(glass_eel_yoy, 
			inclusion %>% filter(sgl_year!=-1), 
			by=(c("ser_id"="sgl_ser_id"))) 
	if (!all(unique(glass_eel_yoy$ser_id)%in% unique(glass_eel_yoy_included$ser_id ))){
		warning("ser_id ",unique(glass_eel_yoy$ser_id)[!unique(glass_eel_yoy$ser_id)%in% 
								unique(glass_eel_yoy_included$ser_id )]," not in inclusion")
	}
	glass_eel_yoy_included <- glass_eel_yoy_included	%>% 
			dplyr::filter(sgl_year <= the_year)
	model_ge_area <- glm(value_std~year_f:area+site,
			data=glass_eel_yoy_included[glass_eel_yoy_included$value>0 & glass_eel_yoy_included$year>1959,],
			family=Gamma(link=log), maxit=300)
	dat_ge <- expand.grid(year_f=model_ge_area$xlevels$year_f,area=model_ge_area$xlevels$area,
			site=model_ge_area$xlevels$site[1])
	dat_ge$year <- as.numeric(as.character(dat_ge$year_f))
	dat_ge$p <- predict(model_ge_area, newdata=dat_ge)
	dat_ge$se <- predict(model_ge_area,newdata=dat_ge,se.fit=TRUE)[["se.fit"]]
	mean_1960_1979 <- aggregate(dat_ge[dat_ge$year<1980,"p"], 
			list(dat_ge[dat_ge$year<1980,"area"]),
			mean)
	names(mean_1960_1979) <- c("area","mean")	
	dat_ge <- merge(dat_ge,mean_1960_1979,by="area")
	dat_ge$p_std_1960_1979 <- exp(dat_ge$p-dat_ge$mean)
	dat_ge$p_std_1960_1979_min <- exp(dat_ge$p-dat_ge$mean-1.96*dat_ge$se)
	dat_ge$p_std_1960_1979_max <- exp(dat_ge$p-dat_ge$mean+1.96*dat_ge$se)
	result <- list()
	result$year <- the_year
	result$nbsite <- length(model_ge_area$xlevels$site)
	result$dat_ge <- dat_ge
	result$delta <- dat_ge_reference$p_std_1960_1979 - dat_ge$p_std_1960_1979
	return(result)
}
res <- mapply(run_exclude_before, the_year=c(2010:2020), SIMPLIFY=FALSE)
require(tidyr)

delta <- lapply(res,function(X)X[["delta"]])
delta <- as.data.frame(delta)
colnames(delta)<-2010:2020
delta$year <- dat_ge$year
delta$area <- dat_ge$area
res_delta <-delta %>% pivot_longer(cols=contains("2"), names_to="year_included",values_to="delta")


g<- ggplot(res_delta)+
		geom_line(aes(x=year,y=delta,color=year_included))+
		facet_wrap( ~area) +
		theme_bw()
figure_inclusion_1<- g
save_figure("figure_inclusion_1",figure_inclusion_1,600,480)


pred <- lapply(res,function(X)X[["dat_ge"]]$"p_std_1960_1979")
pred <- as.data.frame(pred)
colnames(pred)<-2010:2020
pred$year <- dat_ge$year
pred$area <- dat_ge$area
res_pred <-pred %>% pivot_longer(cols=contains("2"), names_to="year_included",values_to="pred")
matplot(pred,ylim=c(0,0.2))
g<-ggplot(res_pred)+geom_line(aes(x=year,y=pred,color=year_included))+ 
		facet_wrap( ~area) +
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()
figure_inclusion_2 <- g
save_figure("figure_inclusion_2",figure_inclusion_2,600,480)
```




## Check on series updates for the 2019 analyses[remove this paragraph]

 `r format(vv[["nCY"]], scientific = TRUE)` time-series  updated to `r CY` `r format(vv[["nCYG"]], scientific = TRUE)` for glass eel `r format(vv[["nCYGY"]], scientific = TRUE)` for glass + yellow eel and `r format(vv[["nCYY"]], scientific=TRUE)` for yellow eel `r format(vv[["nCYm1"]], scientific = TRUE)` 
time-series (`r format(vv[["nCYm1G"]], scientific=TRUE)`} for 
glass eel, ` r format(vv[["nCYm1GY"]], scientific=TRUE)` for glass + yellow eel and
` r format(vv[["nCYm1Y"]], scientific = TRUE)` for yellow eel) were updated to `r CY-1`
only (Table \@ref(tab:xseriesCYm1))).  

`r format(vv[["nseries_lost"]], scientific=TRUE)` time-series have been stopped or not updated
beyond 2016 (`r format(vv[["nseries_lostG"]], scientific=TRUE)` for glass eel,
`r format(vv[["nseries_lostGY"]], scientific =TRUE)` for glass eel + yellow eel and
`r format(vv[["nseries_lostY"]], scientific=TRUE)` for yellow eel (Table
\@ref(tab:xserieslost))) but are still included in the analysis.
Some have stopped reporting either because of a lack of recruits in the case of
the fishery-based surveys (Ems in Germany, stopped in 2001; Vidaa in Denmark, stopped in 1990),
 a lack of financial support (the Tiber in Italy, 2006) or the introduction of
quota from from 2008 to 2011 that has disrupted the five fishery-based French
time-series . The two English series (FlaE and BeeG) are still operating but
data have not been updated since 2016.


```{r tableseriesCY,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE, tab.cap=str_c("Series updated to ",CY, ". Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Area NS = North Sea, EE = Elsewhere Europe, Division = FAO marine division. Series ordered by stage and from North to South")}
autofit(flextable(data = series_CY)%>%
          bold(bold = TRUE, part = "header"))
```

```{r xseriesCYm1, echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,tab.cap=str_c("Series updated to ",CY-1, " see table \\@ref(tab:tableseriesCY) for codes. Series ordered from North to South")}
autofit(flextable(data = series_CYm1)%>%
          bold(bold = TRUE, part = "header"))

```

```{r xserieslost,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,tab.cap=str_c("table_serieslost")}
autofit(flextable(data = series_lost)%>%
          bold(bold = TRUE, part = "header"))
```


## Raw data
 
Calculation of the geometric mean of all time-series [^1] is given in (Figures
\@ref(fig:figure3) and \@ref(fig:figure4)). 

[^1]: This figure is given as it
  consistent with the trend provided by WGEEL from 2002 to 2006. The scaling is
  performed on the 1979-1994 average of each time-series, and `r `length(vv[["sc_1979_1994_unused_series"]])` time-series without data during that
  period are excluded from the analysis. The time-series left out are : 
  `r paste(vv[["sc_1979_1994_unused_series"]],collapse=", ")`

```{r figure3, fig.cap=paste("Time-series of glass eel and yellow eel recruitment in European rivers with time-series having data for the 1979-1994 period (", vv[["sc_1979_1994_nb"]], "sites). Each time-series has been scaled to its 1979-1994 average. Note the logarithmic scale on the y-axis. The mean values and their bootstrap confidence interval (95%) are represented as black dots and bars. Geometric means are presented in red."), fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE}
knitr::include_graphics(paste0(imgwd,'figure3.png'))
```


```{r figure4, fig.cap=paste("Time-series of glass eel and yellow eel recruitment in Europe with",vv[["sc_1979_1994_nb"]],"time-series out of the", vv[["nb_series_init"]],"available to the working group. Each time-series has been scaled to its 1979-1994 average. The mean values of combined yellow and glass eel time-series and their bootstrap confidence interval (95%) are represented as black dots and bars. The brown line represents the mean value for yellow eel, the blue line represents the mean value for glass eel time-series. The range of  these  time-series  is  indicated  by  a  grey  shade.  Note that individual time-series  from  Figure \\@ref(fig:figure3)  were  removed to make the mean value more clear.  Note also the logarithmic scale on the y-axis."), fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,'figure4.png'))
```

## GLM based trend

The WGEEL recruitment index used in the ICES Annual Stock Advice is fitted using
a GLM (Generalised Linear Model) with gamma distribution and a log link: 
$glass eel \sim year:area + site$, where $glass eel$ is individual glass eel
time-series, including both pure G series and those identified as a mixture of
glass and yel-low eel (G+Y), $site$ is the site monitored for recruitment,
area is either the continental North Sea or Elsewhere Europe, and year is the
year coded as a categorical value.
For yellow eel time-series, only one estimate is provided: $yellow~eel \sim year + site$. 

The trend is hindcast using the predictions from 1960 onwards for
`r vv$modelge$nbsite` glass eel time-series and from 1950 onwards for
`r vv$modelolder$nbsite` yellow eel time-series.
Some zero values have been excluded from the GLM analysis: 
`r nrow(vv$modelge$value_excluded_zero)` for the glass eel model and
`r nrow(vv$modelolder$value_excluded_zero)` for the yellow eel model. This
treatment is parcimoniuous and tests shows it has no effect on the trend (ICES,
2017).

The reconstructed values are then aggregated using geometric means of the two
reference area (Elsewhere Europe EE, and North Sea NS). The predictions are given 
in reference to the geometric mean of the 1960-1979 period.
Note that the shift from arithmetic to geometric means was done this year
because *post-hoc* model checking confirmed that log-normal (or Gamma
Distribution) and geometric means are the prefered choice. 



As some of the values were not complete the 2018, the
level of European eel recruitment compared to the 1960-1979 average has changed 
when compared to last year report. The value has decreased from 9.6% in last
year report to `r round(100*synthesis[nrow(synthesis)-1,"Elsewhere Europe"], digits= 1)`% for the Elsewhere Europe area.  It remains unchanged 
 for the North Sea at `r round(100*synthesis[nrow(synthesis)-1,"North Sea"], digits =1)`%.
 For 2019, data are **only provisional** and give estimates at
  `r round(100*synthesis[nrow(synthesis),"North Sea"], digits =1)`% for the North Sea and `r round(100*synthesis[nrow(synthesis),"Elsewhere Europe"], digits= 1)`% for the
Elsewhere Europe area, but some of the series are not yet complete 
(Figure \@ref(fig:figure5) \@ref(fig:figure5withlogscale) (log.scale), 
Tables \@ref(tab:tableglmglasseel)).


```{r figure5, fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.cap=paste("WGEEL recruitment index: estimated (GLM) glass eel recruitment for the continental North Sea and Elsewhere Europe series with 95% confidence intervals updated to", CY,". The GLM ($glass eel \\sim area:year+site$)  was  fitted  on", vv$modelge$nbsite,"time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. The predictions $p$ have been scaled to the 1960-1979 average $\\bar{p}_{1960-1979}$. Number of series",pull(vv$nb_series_glass_eel_per_area[1,1]), "=\\n", pull(vv$nb_series_glass_eel_per_area[1,2]), "\\n", pull(vv$nb_series_glass_eel_per_area[2,1]),"\\n", pull(vv$nb_series_glass_eel_per_area[2,2]))}
#fig.cap=paste("WGEEL recruitment index: estimated (GLM) glass eel recruitment for the continental North Sea and Elsewhere Europe series with 95% confidence intervals updated to", CY,". The GLM ($glass eel \sim area:year+site$)  was  fitted  on", vv$modelge$nbsite,"time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. The predictions $p$ have been scaled to the 1960-1979 average $\bar{p}_{1960-1979}$. Number of series",pull(vv$nb_series_glass_eel_per_area[1,1]), "=\n", pull(vv$nb_series_glass_eel_per_area[1,2]),"\n",pull(vv$nb_series_glass_eel_per_area[2,1]),"\n",pull(vv$nb_series_glass_eel_per_area[2,2]))
knitr::include_graphics(paste0(imgwd,"figure5_without_logscale_ribbon.png"))
```

For yellow eel series, the autumn ascent has not been recorded yet and most of
the series have reported data till the middle of the summer. The `r CY-1` yellow eel
index is at `r round(100*dat_ye[dat_ye$year==CY-1,"value_std_1960_1979"], digits=1)`% of
the 1960-1979 baseline. 


```{r figure6, fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,fig.cap=paste("Geometric mean of estimated (GLM) yellow eel recruitment for Europe updated to",CY,". The GLM (yellow eel ~ year+site) was fitted to",vv[["nb_for_yellow_eel_glm"]],"yellow eel time-series $p$ and scaled to the 1960-1979 average $\\bar{p}_{1960-1979}$.")}
#fig.cap=paste("Geometric mean of estimated (GLM) yellow eel recruitment for Europe updated to",CY,". The GLM ($yellow eel \sim year+site$) was fitted to",vv[["nb_for_yellow_eel_glm"]],"yellow eel time-series $p$ and scaled to the 1960-1979 average $\bar{p}_{1960-1979}$.")
knitr::include_graphics(paste0(imgwd,"figure6_without_log_scale.png"))
```


```{r figure6Baltic, fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,fig.cap=paste("Geometric mean of estimated (GLM) yellow eel recruitment for Europe updated to",CY,". The GLM (yellow eel ~ year:area+site) was fitted to",vv[["nb_for_yellow_eel_glm"]],"yellow eel time-series $p$ and scaled to the 1960-1979 average $\\bar{p}_{1960-1979}$.")}
#fig.cap=paste("Geometric mean of estimated (GLM) yellow eel recruitment for Europe updated to",CY,". The GLM ($yellow eel \sim year+site$) was fitted to",vv[["nb_for_yellow_eel_glm"]],"yellow eel time-series $p$ and scaled to the 1960-1979 average $\bar{p}_{1960-1979}$.")
knitr::include_graphics(paste0(imgwd,"figure6_without_log_scale_BalticEffect.png"))
```

## Is there a positive trend in recruitment ?
After high levels in the late 1970s, the recruitment declined and has been very
low for all years after 2000. From ICES (2014) onward a change in the
recruitment has been detected. One of the test used to show that change in 2014
was based on SGIPEE(2011) working group. We have used a test only slighly
different from the test used in ICES 2011. The difference is that the model is
now based on individual series as source data, not only the prediction. The model differs from that used by
wgeel also as year is here treated as a continuous value, whereas it is treated
as a factor in the glm for recruitment, and the years are restricted to
decreasing part of the recruitment (after 1980).
\begin{equation}
glass~eel \sim  \alpha_{site} site + \beta_{area} Y_{>=1980} + \gamma_{area} Y_{>2011} + \epsilon,
\end{equation}
where glass eel is the number of glass eel in the glass eel series, either for the Elsewhere Europe or the North Sea time series,  $year_{year>1980}$
is a continuous value corresponding to year after 1980, $year_{year>2011}$ is also
a continuous value, $\epsilon$ is a random error with mean 0 and standard deviation sigma, 
and $\alpha_{site}$, $\beta_{area}$ and $\gamma_{area}$ are the estimated
parameters. The parameters $\gamma_{area}$ are higly significant both in the
Elsewhere Europe area (p=`r round(sgipee_test_for_change_ee,digits=1)`
and for the North Sea p=`r round(sgipee_test_for_change_ns,digits=1)` North Sea.
This result confirms that there has been a change in the recruitment slope.

\textcolor{purple}{Add a table with past coeff, current coeff, and probabilities and diminish the text}

To test whether there is an increase in recruitment since 2011 the slope of $\beta_{area}+\gamma_{area}$, 
i.e. the slope of the recent increase in
recruitment is positive, the NULL hypothesis $H0:b>0$ is tested.

To summarize, after high levels in the late 1970s, the recruitment declined and has been very
low for all years after 2000. There has been a change in the trend in 2011, the
recruitment has stopped to decrease, and has been increasing in the period
2011-2019 with a rate significantly different from zero. However,  this increase needs
to be taken very carefully. Firstly , not all series have been reported for 2019
and the results might change  when missing data is incorporated to the analysis. 
Secondly, even if the results would not change, recruitment remains very low
`r round(100*synthesis[nrow(synthesis),"North Sea"], digits =1)`% for the North Sea 
and `r round(100*synthesis[nrow(synthesis),"Elsewhere Europe"], digits= 1)`% for the
Elsewhere Europe area. Recruitment has been continually decreasing
from 1980 to 2011 (31 years), thus, the positive trend should be maintained during more years in order
to consider that the stock is safe. In that sense and finally,  during the 2011-2019 period, 
the maximum values were reached in 2014; but recruitment has been decreasing
since then.


```{r tableglmglasseel,echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,tab.cap=str_c("GLM $glass~eel \\sim year:area + site $ geometric means of predicted values for ",vv$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period.")}
columns = names(gg)
years = rep(196:202,each=2)*10
flextable(gg%>% rownames_to_column(" ") %>%
            setNames(0:ncol(gg))) %>%
  delete_part(part = "header") %>%
  add_header_row(values=c("",years),top=FALSE) %>%
  merge_h(part="header") %>%
  add_header_row(values=c("",columns),top=FALSE) %>%
  bold(bold = TRUE, part = "header") %>%
  theme_booktabs(x, bold_header = FALSE)
```

```{r tableglmyellow,echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,tab.cap=str_c("GLM $glass~eel \\sim year + site $ geometric means of predicted values for ",vv$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period.")}
flextable(yy %>% rownames_to_column(" "))%>%
  bold(bold = TRUE, part = "header")
```



```{r tableglmyellowBaltic,echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,tab.cap=str_c("GLM $glass~eel \\sim year:area + site $ geometric means of predicted values for ",vv$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period.")}
columns = names(yy_BalticEffect)
years = rep(195:202,each=2)*10
flextable(yy_BalticEffect%>% rownames_to_column(" ") %>%
            setNames(0:ncol(yy_BalticEffect))) %>%
  delete_part(part = "header") %>%
  add_header_row(values=c("",years),top=FALSE) %>%
  merge_h(part="header") %>%
  add_header_row(values=c("",columns),top=FALSE) %>%
  bold(bold = TRUE, part = "header") %>%
  theme_booktabs(x, bold_header = FALSE)
```



# Annex
```{r diagramme,echo=FALSE,eval=FALSE,results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
if(!require(DiagrammeR)) install.packages("DiagrammeR") ; require(DiagrammeR)
if(!require(magrittr)) install.packages("magrittr") ; require(magrittr)
if(!require(DiagrammeRsvg)) install.packages("DiagrammeRsvg") ; require(DiagrammeRsvg)
if(!require(rsvg)) install.packages("rsvg") ; require(rsvg)

node_list <- create_node_df(n=16,		
		type=rep(c("box",
						"value"), 16
		),
		label=c(
				str_c("Series available in ", CY),
				vv$nb_series_init,
				"used",
				vv$nb_series_final,
				"G + GY",
				vv$nb_series_glass_eel,
				"Y",
				vv$nb_series_older,
				"NS",
				as.numeric(vv$nb_series_glass_eel_per_area[vv$nb_series_glass_eel_per_area$area=="Elsewhere Europe",2]),
				"EE",
				as.numeric(vv$nb_series_glass_eel_per_area[vv$nb_series_glass_eel_per_area$area=="North Sea",2]),
				"< 10 Y",
				as.numeric(vv$ser_qal_id_count[vv$ser_qal_id_count$ser_qal_id==0,"len"]),
				"discarded",
				as.numeric(vv$ser_qal_id_count[vv$ser_qal_id_count$ser_qal_id==3,"len"])
		),
		color=c(rep("green",12),"orange","orange","red","red"),
		style="filled",
		shape=rep(c("plaintext","circle"),8),
		value=1:16,
		fixedsize =FALSE
)

edge_list<-create_edge_df(
		from=c(1,2,3,4,5,4,7,2 ,2 ,13,15,6,6,11,9),
		to=  c(2,3,4,5,6,7,8,13,15,14,16,9,11,12,10),
		rel="a",
		label=rep(" ",15),
		color=rep("grey",15),
		length=100)



igraph1 <- create_graph( attr_theme = NULL)

igraph2 <- igraph1%>%
		add_nodes_from_table(table = node_list, 
				type_col=type,
				label_col=label) 
#igraph2 %>% get_node_df()
# Add the edges to the graph
igraph3 <-igraph2 %>%
		add_edges_from_table(
				table = edge_list,
				from_col = from,
				to_col = to,
				from_to_map = id_external
		)

render_graph(igraph3, layout="tree")%>%
render_graph(igraph3, layout="tree") %>% 
export_svg %>% read_xml %>% write_xml(str_c(imgwd,"series_selection.png"))

render_graph(igraph3, layout="tree") %>% 
		export_svg %>%  charToRaw %>% rsvg_png(str_c(imgwd,"series_selection.png"))

```

## Additional figures

We provide the same figures as in the main text but Figure \@ref(fig:figure3withoutlogscale) 
without log scale for Figure \@ref(fig:figure3). For the prediction, figures with log
scales are provided (Figures \@ref(fig:figure5withlogscale) and
\@ref(fig:figure6withlogscale)).

```{r figure3withoutlogscale, fig.cap="Same as figure \\@ref(fig:figure3) but without log scale", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure3withoutlogscale.png"))
```


```{r figure5withlogscale, fig.cap="Same as figure \\@ref(fig:figure5) but with a log scale.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure5_ribbon.png"))
```

```{r figure6withlogscale, fig.cap="Same graph as figure \\@ref(fig:figure6) but with a log scale.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure6.png"))
```

```{r figure6withlogscale_BalticEffect, fig.cap="Same graph as figure \\@ref(fig:figure6) but with a log scale.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure6_BalticEffect.png"))
```




## Exploitation Rates
By dividing glass eel declared landing by the time series of abundance, we an derive a relative indicator of glass eel mortality exploitation rate that can inform on trends in glass eel fishing mortality. The analysis is restricted to Elsewhere Europe since no commercial fisheries took place in the North Sea area in the last years. Moreover, we restricted the analysis to the post 2000 period since recent ICES data call have focused on these decades. While some landings data are still missing, the diagram suggests that the exploitation rate for glass has decreased after the implementation of the Eel Regulation in 2009 (the drop in 2009 is mostly due to missing French data for this given year) and reached its lowest level from 2014 to 2017. Since then, the exploitation rate appears to have slightly re-increcreased though not reaching pre Eel Regulation levels. This type of analysis reinforces the need of a landing workshop in order to reconstruct time series of landings and to explore how landings can be used can be used in the advice on fishing opportunities. This exercise is currently only feasible for glass eel recruitment: while landings data are available for other stages, we are still missing abundance indices of yellow eel standing stock of for silver eel abundance (see chapter 3).



```{r fishingmortalitydata,  warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
query="select sum(eel_value),eel_year,eel_emu_nameshort,eel_cou_code from datawg.t_eelstock_eel where eel_typ_id=4 and eel_qal_id=1 and eel_lfs_code in ('G','GY') and eel_year >= 2000 group by eel_year, eel_emu_nameshort,eel_cou_code "
landings=dbGetQuery(con,query) %>%
  na.omit() %>%
  mutate(area=ifelse(eel_cou_code %in% c("DK","NO","NL","DE") | eel_emu_nameshort %in% c("GB_Scot","GB_Nort","GB_Humb","GB_Angl","GB_Tham"),
                     "North Sea","Elsewhere Europe"))
emusNS <-landings %>%
  filter(area=="North Sea") %>%
  arrange(eel_emu_nameshort) %>%
  dplyr::select(eel_emu_nameshort) %>%
  unique() %>%
  dplyr::pull() %>%
  paste(collapse=", ")
emusEE <-landings %>%
  filter(area!="North Sea") %>%
  arrange(eel_emu_nameshort) %>%
  dplyr::select(eel_emu_nameshort) %>%
  unique() %>%
  dplyr::pull() %>%
  paste(collapse=", ")
                

landings <- landings %>%
  dplyr::group_by(eel_year,area) %>%
  dplyr::summarize(landings=sum(sum, na.rm=TRUE)) %>%
  dplyr::rename(year_f=eel_year) %>%
  ungroup()

rates <- left_join(dat_ge%>% mutate(year_f=as.numeric(as.character(year_f))),landings ) %>%
  filter(year_f >= 2000) %>%
  filter(area=="Elsewhere Europe")

dbDisconnect(con)
```





```{r fishingmortality, fig.cap=paste("Reported G and GY commerical landings divided by recruitment index for EE (including landings reported in EMUs",emusEE,". The resulting ratio is a relative proxy of the exploitation rate that inform on trends in fishing mortality. The graph is restricted to the post Eel Regulation period since landings data are thought to be of better quality since then. Note that 2000 landings data is not available, 2009 for France and are only available from 2014 to 2019 for Italy. "), fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}

ggplot(rates,aes(x=year_f)) +geom_ribbon(aes(ymin=landings/p_std_1960_1979_max, 
                                             ymax=landings/p_std_1960_1979_min),
                                         alpha=.3) +
  geom_line(aes(y=landings/p_std_1960_1979))+
  geom_point(aes(y=landings/p_std_1960_1979))+
  xlab("") + 
  scale_x_continuous(breaks=seq(2000,2022,3), labels=seq(2000,2022,3))+
  ylab("Reported landings divided by glass eel recruitment index") +
  theme_bw()

ggsave(paste0(imgwd,"rates.png"),width=16/2.54,height=12/2.54,dpi=300)


```


## Notes to ACOM
 
 \textcolor{red}{Were there comments raised last year ?}

## Shiny tab on data visualisation
 