---
title: "MARSS_models"
author: "Torbjörn Säterberg"
date: today  
format: html
embed-resources: true
editor: visual
code-fold: true
---

## Introduction

This script is used to fit MARSS-models to silver eel time series. Different sub-population structures (different structures of hidden trends) are tested and models are compared using information criteria. Hypothesis tested are:
* H1: Panmictic (all series share the same trend)
* H2: North sea vs. Elsewhere europé (base on recruitment model)
* H3:	Habitat(sub-population trends based on habitat)
* H4:	Stocking vs not stocked(sub-population structure based on if the time series is affected by stocking or not)
* H5:	ICES ecoregion (sub-population trends based on ICES ecoregion)


## R-packages

```{r}
load_library(MARSS)
load_library(gridExtra)
load_library(xtable)
load_library(getPass)
load_library(RPostgres)
load_library(sf)
load_library(flextable)
load_library(broom)
load_library(eulerr)
load_library(dplyr)
load_library(knitr)
load_library(ggplot2)
load_library(ggmap)
load_library(tidyverse)
load_library(rnaturalearth)
load_library(parallel)
load_library(kableExtra)
load_library(mgcv)
load_library(ggmap)
load_library(ggrepel)
load_library(grid)
load_library(flextable)
load_library(yaml)
```

#### Connect to wgeel database
```{r}
getwd()
cred=read_yaml('../../credentials.yml') # credentials


# connect to 
con_wgeel = dbConnect(Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=getPass())

```

#### Read data
```{r}
# load data
query='SELECT 
		das_id,
		das_value,
		das_effort,
		das_year,
		das_comment,
		ser_id,            
		cou_order,
		ser_nameshort,
		ser_area_division,
		ser_qal_id,
    ser_hty_code,
    ser_emu_nameshort,
    ser_uni_code,
    ser_cou_code,
    ser_comment,
    sam_samplingtype,
    ser_sam_id, ser_distanceseakm, ser_method, ser_sam_gear, ser_restocking,
		das_qal_id,
		das_last_update,
		f_subarea,
		lfs_code,          
		lfs_name
		from datawg.t_dataseries_das 
		join datawg.t_series_ser on das_ser_id=ser_id
		left join ref.tr_samplingtype_sam on ser_sam_id=sam_id
		left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
		left join ref.tr_faoareas on ser_area_division=f_division
        left join ref.tr_country_cou on cou_code=ser_cou_code
		where ser_typ_id in (2,3) and das_value is not null and  (ser_qal_id IS NULL OR ser_qal_id IN (0,1,2,4)) and (das_qal_id IS NULL OR das_qal_id IN (1,2,4))'
mydata = dbGetQuery(con_wgeel,query)

# make factors
mydata$ser_nameshort=as.factor(mydata$ser_nameshort)
mydata$ser_area_division=as.factor(mydata$ser_area_division)
mydata$f_subarea=as.factor(mydata$f_subarea)
mydata$lfs_code=as.factor(mydata$lfs_code)
mydata$ser_cou_code=as.factor(mydata$ser_cou_code)
mydata$ser_emu_nameshort=as.factor(mydata$ser_emu_nameshort)
mydata$lfs_name=as.factor(mydata$lfs_name)
mydata$ser_hty_code=as.factor(mydata$ser_hty_code)

# total number including those with only NULL value
nb_yellow = dbGetQuery(con_wgeel, "	SELECT count(*) FROM datawg.t_series_ser	WHERE  ser_typ_id in (2)") %>% pull()
nb_silver = dbGetQuery(con_wgeel, "	SELECT count(*) FROM datawg.t_series_ser	WHERE  ser_typ_id in (3)") %>% pull()

#sampling=read.table("sampling.csv",header=TRUE,sep=";")
sampling = dbGetQuery(con_wgeel, "SELECT ser_id,	ser_nameshort,	ser_comment,	sam_samplingtype,	ser_uni_code,	gea_name_en AS type FROM datawg.t_series_ser LEFT OUTER JOIN ref.tr_gear_gea ON (gea_id = ser_sam_gear)  LEFT OUTER JOIN ref.tr_samplingtype_sam ON (sam_id = ser_sam_id) WHERE ser_typ_id IN (3)")
mydata = merge(mydata,sampling[,c("ser_id","type")])
```

## Filter data
```{r}
S_data <- mydata %>%
  select("das_year","ser_nameshort","das_value") %>%
pivot_wider(names_from=ser_nameshort,values_from = das_value)

S_data %>% complete()
```


## Fit MARSS models
```{r}
data("harborSeal")
harborSeal

years <- harborSeal[, 1] # first col is years
# leave off Hood Canal data for now
sealData <- t(harborSeal[, c(2:7, 9:13)])


# H1 stock
Z1 <- factor(c("wa.or", "wa.or", rep("ps", 4),
"ca", "ca", "wa.or", "wa.or", "bc"))

# H2 coastal+PS
Z2 <- factor(c(rep("coast", 2), rep("ps", 4), rep("coast", 4), "ps"))

# H3 N and S
Z3 <- factor(c(rep("N", 6), "S", "S", "N", "S", "N"))

# H4 North Coast, Inland Strait, Puget Sound, South Coast
Z4 <- factor(c("nc", "nc", "is", "is", "ps", "ps",
"sc", "sc", "nc", "sc", "is"))

# H5 panmictic
Z5 <- factor(rep("pan", 11))

# H6 Site
Z6 <- factor(1:11) # site
Z.models <- list(Z1, Z2, Z3, Z4, Z5, Z6)
names(Z.models) <-
c("stock", "coast+PS", "N-S", "NC+Strait+PS+SC", "panmictic", "site")

# test with different Q models(i.e. different process errors)
Q.models <- c("diagonal and equal", "diagonal and unequal")

# Model parameters(the same across  all models) 
U.model <- "unequal"
R.model <- "diagonal and equal"
A.model <- "scaling"
B.model <- "identity"
x0.model <- "unequal"
V0.model <- "zero"
model.constant <- list(
U = U.model, R = R.model, A = A.model,
x0 = x0.model, V0 = V0.model, tinitx = 0
)


```

## Fit MARSS-models
```{r}
out.tab <- NULL
fits <- list()
for (i in 1:length(Z.models)) {
for (Q.model in Q.models) {
fit.model <- c(list(Z = Z.models[[i]], Q = Q.model), model.constant)
fit <- MARSS(sealData,
model = fit.model,
silent = TRUE, control = list(maxit = 1000)
)
out <- data.frame(
H = names(Z.models)[i], Q = Q.model, U = U.model,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(Z.models[[i]])),
num.iter = fit$numIter, converged = !fit$convergence,
stringsAsFactors = FALSE
)
out.tab <- rbind(out.tab, out)
fits <- c(fits, list(fit))
if (i == 5) next # one m for panmictic so only run 1 Q
}
}

```

## summarize model support
```{r}

# reorder based on model fit
min.AICc <- order(out.tab$AICc)
out.tab.1 <- out.tab[min.AICc, ]

# AICc differences
out.tab.1 <- cbind(out.tab.1,
delta.AICc = out.tab.1$AICc - out.tab.1$AICc[1])

# Relative likelihood is defined as exp(−∆AICc/2).
out.tab.1 <- cbind(out.tab.1,
rel.like = exp(-1 * out.tab.1$delta.AICc / 2)
)

#The AIC weight for a model is its relative likelihood divided by the sum of all the relative likelihoods.
out.tab.1 <- cbind(out.tab.1,
AIC.weight = out.tab.1$rel.like / sum(out.tab.1$rel.like)
)
)

```

## make nice table
```{r}
flextable(out.tab.1)
```


