
```{r setup, include=FALSE}
source("../../utilities/load_library.R")


knitr::opts_chunk$set(echo = TRUE,warning=FALSE,message=FALSE,
                      fig.width=14.9/2.54,
                      dpi=300,
                      fig.height=10/2.54)


load_library("RPostgres")
load_library("dplyr")
load_library("tidyr")
load_library("readxl")
load_library("yaml")

cred=read_yaml("../../../credentials.yml")
con_wgeel = dbConnect(Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=cred$password)
```

```{r data loading, include = FALSE}
query='SELECT 
		das_id,
		das_value,
		das_effort,
		das_year,
		das_comment,
		ser_id,            
		cou_order,
		ser_nameshort,
		ser_area_division,
		ser_qal_id,
    ser_hty_code,
    ser_emu_nameshort,
    ser_uni_code,
    ser_cou_code,
    ser_comment,
    sam_samplingtype,
    ser_sam_id, ser_distanceseakm, ser_method, ser_sam_gear, ser_restocking,
		das_qal_id,
		das_last_update,
		f_subarea,
		lfs_code,          
		lfs_name
		from datawg.t_dataseries_das 
		join datawg.t_series_ser on das_ser_id=ser_id
		left join ref.tr_samplingtype_sam on ser_sam_id=sam_id
		left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
		left join ref.tr_faoareas on ser_area_division=f_division
        left join ref.tr_country_cou on cou_code=ser_cou_code
		where ser_typ_id in (2,3) and das_value is not null and  (ser_qal_id IS NULL OR ser_qal_id IN (0,1,2,4)) and (das_qal_id IS NULL OR das_qal_id IN (1,2,4))'

mydata = dbGetQuery(con_wgeel,query) # Get yellow and silver eel time series from WGEEL database

dbDisconnect(con_wgeel) #disconnect from WGEEL database

d.effort = read_xlsx("data/effort overview.xlsx") #Load overview of effort type and availability that was manually made at WGEEL 2023

d.ecoregion = read.csv2("data/points_with_ecoregions_forRob.csv") %>% #Load data on ecoregion of dataseries
  rename(ecoregion = new_Ecoreg)

####################
### Get data in right format
data <- mydata %>%
  filter(lfs_code == "S") %>% #Filter data down to silver eel timeseries
  arrange(ser_nameshort, das_year) %>% # Sort data for better overview
  left_join(d.ecoregion %>% select(ser_id, ecoregion, distance_to_ecoregion)) # Add ecoregion info
  
####################
### Filter data down to relevant silver eel series

# Filter data according to time series length, and the availability of effort data
# If no data on effort is known, then the series cannot be used to analyse trends in abundance/CPUE.

# Sometimes, no effort data is given because all silver eel passing through a river are sampled. This data is kept here, 
# perhaps advise in next year's data call to set such effort equal to 1 in the das_effort column
  
min.length = 10 #minimum time-series length, delete series with fewer number of years

#Overview table to be used in the subgroup text to show which series were kept and which were discarded
t.filterchoice <- data %>% 
  count(ser_nameshort, ser_method) %>% #filter data down to series name and method, while counting time series length
  left_join(d.effort %>% select(ser_nameshort, effort, notes)) %>% #Add information on effort type/availability
  mutate(filtered = case_when(
    n < min.length ~ "Dropped", # Set a variable specifying if the column should be filtered out based on time-series length
    effort == "unknown" ~ "Dropped", # Drop series with unknown effort
    ser_nameshort %in% c("NorwS", "WepeS") ~ "Dropped", #These two series have had trouble reporting in recent years, data for those years not reliable, drop until issue is resolved.
    TRUE ~ "Kept"     
  ),
  reason.dropped = case_when(
    n < min.length ~ paste("Number of years fewer than",min.length, sep = " "), 
    effort == "unknown" ~ "No effort given", 
    ser_nameshort %in% c("NorwS", "WepeS") ~ "Inconsistencies in data", 
    TRUE ~ ""     
  )
  )
  

### NOTE: LevS reports no effort (assumed constant effort), but lists multiple years with deviations in sampling times, and thus different effort. Choose what to do with those.
 

# Apply the filter to the data, calculate CPUE, process data to output format
d.cpue <- data %>%
  left_join(t.filterchoice %>% select(ser_nameshort, effort, filtered)) %>% #add filter choice
  filter(filtered != "Dropped") %>% #filter out selected series
  mutate(cpue = case_when(
    ser_uni_code == "index" ~ das_value,
    ser_uni_code == "nr/m2" ~ das_value,
    ser_uni_code == "kg/ha" ~ das_value,
    ser_uni_code == "nr" & effort == "constant" ~ das_value,
    ser_uni_code == "nr" & effort == "model estimate" ~ das_value,
    ser_uni_code == "kg" & effort == "model estimate" ~ das_value,
    TRUE ~ das_value/das_effort
  )
  ) %>% #calculate cpue if effort data is given, otherwise assume that das_value is already CPUE
  select(das_id, das_year, cpue, das_value, das_effort, ser_id, ser_nameshort, ser_hty_code, ser_emu_nameshort, ser_cou_code, ser_distanceseakm, ser_restocking, ecoregion, distance_to_ecoregion, das_qal_id, ser_qal_id)

dbDisconnect(con_wgeel)
```

### Data selection

```{r table_filter, echo = FALSE, tab.cap = "Available silver eel time series. Based on the number of years of available data and the availability of effort data, it is shown whether or not a given series was included in the analysis."}
table <- t.filterchoice %>%
  select(!ser_method) %>% # drop method description
  mutate(notes = ifelse(is.na(notes), "", notes)) %>% #change NAs to blanks in notes
  rename("Series name" = ser_nameshort, #rename table headers
         "Years (n)" = n,
         "Effort data" = effort,
         "Filtered" = filtered,
         "Drop reason" = reason.dropped,
         "Comments" = notes)

knitr::kable(table)
```


