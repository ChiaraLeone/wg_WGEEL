
```{r setup, include=FALSE}
source("../../utilities/load_library.R")


knitr::opts_chunk$set(echo = TRUE,warning=FALSE,message=FALSE,
                      fig.width=14.9/2.54,
                      dpi=300,
                      fig.height=10/2.54)


load_library("RPostgres")
load_library("dplyr")
load_library("tidyr")
load_library("readxl")
load_library("yaml")
load_library("ggplot2")

cred=read_yaml("../../../credentials.yml")
con_wgeel = dbConnect(Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=cred$password)
```

```{r data loading, include = FALSE}
query='SELECT 
		das_id,
		das_value,
		das_effort,
		das_year,
		das_comment,
		ser_id,            
		cou_order,
		ser_nameshort,
		ser_area_division,
		ser_qal_id,
    ser_hty_code,
    ser_emu_nameshort,
    ser_uni_code,
    ser_cou_code,
    ser_comment,
    sam_samplingtype,
    ser_sam_id, ser_distanceseakm, ser_method, ser_sam_gear, ser_restocking,
		das_qal_id,
		das_last_update,
		f_subarea,
		lfs_code,          
		lfs_name
		from datawg.t_dataseries_das 
		join datawg.t_series_ser on das_ser_id=ser_id
		left join ref.tr_samplingtype_sam on ser_sam_id=sam_id
		left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
		left join ref.tr_faoareas on ser_area_division=f_division
        left join ref.tr_country_cou on cou_code=ser_cou_code
		where ser_typ_id in (2,3) and das_value is not null and  (ser_qal_id IS NULL OR ser_qal_id IN (0,1,2,4)) and (das_qal_id IS NULL OR das_qal_id IN (1,2,4))'

mydata = dbGetQuery(con_wgeel,query) # Get yellow and silver eel time series from WGEEL database

dbDisconnect(con_wgeel) #disconnect from WGEEL database

d.ecoregion = read.csv2("data/points_with_ecoregions_forRob.csv") %>% #Load data on ecoregion of dataseries
  rename(ecoregion = new_Ecoreg)

####################
### Get data in right format
data <- mydata %>%
  filter(lfs_code == "S") %>% #Filter data down to silver eel timeseries
  arrange(ser_nameshort, das_year) %>% # Sort data for better overview
  left_join(d.ecoregion %>% select(ser_id, ecoregion, distance_to_ecoregion)) # Add ecoregion info
  
####################
### Assign type of effort data available and any relevant notes
d.effort = data %>%
  select(ser_nameshort) %>%
  unique() %>%
  mutate(effort = case_when(
    ser_nameshort %in% c("BI1S",  "BI4S",  "BreS",  "FreS",  "KilS",  "KotkS", "LoiS",  "MinS",  "MonS",  "NkaS",  "NSIS",  "OriS",  "PanS", "SeNS",  "SosS",  "SouS",  "StrS",  "DaugS",  "LilS" ) ~ "provided",
    ser_nameshort %in% c("BRWS",  "DoijS", "HVWS",  "IjsS",  "NiWS",  "NZKS",  "PobeS", "PogoS", "PolsS", "TibeS", "ZMaS" ) ~ "index",
    ser_nameshort %in% c("BaBS",  "BidS",  "BurS",  "EamtS", "FowS",  "GiBS",  "ImsaS", "KavlS", "LevS",  "NalS",  "NorwS", "ShiS",  "VaakS",  "WepeS") ~ "constant",
    ser_nameshort %in% c("RibS", "VilS", "WarS") ~ "model estimate",
    ser_nameshort %in% c("AlauS", "AlCS",  "CurlS", "KertS", "KreS",  "LakS",  "RieS",  "RubS",  "SiesS", "ZeiS" ) ~ "unknown"
 ),
 notes = case_when(
   ser_nameshort %in% c("AlauS",  "CurlS",  "KertS",  "KreS", "LakS",  "RieS",  "RubS",  "SiesS",  "ZeiS") ~ "Next year double check for available effort data on all similar Lithuanian series, and check if only silver eel are reported",
   ser_nameshort %in% c("AlCS") ~ "A mean of a subsample of commercial catches, no effort known",
   ser_nameshort %in% c("NorwS",  "WepeS") ~ "Recent years reported as 0, but actually no information available"
 )
 )

if(any(is.na(d.effort$effort))){
  stop("qualitative effort information from the following series is missing: ", 
                paste(d.effort$ser_nameshort[which(is.na(d.effort$effort))], collapse = ", "),
                ". Manually insert this into the d.effort dataframe before proceeding.")
}

### Filter data down to relevant silver eel series

# Filter data according to time series length, and the availability of effort data
# If no data on effort is known, then the series cannot be used to analyse trends in abundance/CPUE.

# Sometimes, no effort data is given because all silver eel passing through a river are sampled. This data is kept here, 
# perhaps advise in next year's data call to set such effort equal to 1 in the das_effort column
  
min.length = 10 #minimum time-series length, delete series with fewer number of years

#Overview table to be used in the subgroup text to show which series were kept and which were discarded
t.filterchoice <- data %>% 
  count(ser_nameshort, ser_method) %>% #filter data down to series name and method, while counting time series length
  left_join(d.effort %>% select(ser_nameshort, effort, notes)) %>% #Add information on effort type/availability
  mutate(filtered = case_when(
    n < min.length ~ "Dropped", # Set a variable specifying if the column should be filtered out based on time-series length
    effort == "unknown" ~ "Dropped", # Drop series with unknown effort
    ser_nameshort %in% c("NorwS", "WepeS") ~ "Dropped", #These two series have had trouble reporting in recent years, data for those years not reliable, drop until issue is resolved.
    TRUE ~ "Kept"     
  ),
  reason.dropped = case_when(
    n < min.length ~ paste("Number of years fewer than",min.length, sep = " "), 
    effort == "unknown" ~ "No effort given", 
    ser_nameshort %in% c("NorwS", "WepeS") ~ "Inconsistencies in data", 
    TRUE ~ ""     
  )
  )
  

### NOTE: LevS reports no effort (assumed constant effort), but lists multiple years with deviations in sampling times, and thus different effort. Choose what to do with those.
 

# Apply the filter to the data, calculate CPUE, process data to output format
d.cpue <- data %>%
  left_join(t.filterchoice %>% select(ser_nameshort, effort, filtered)) %>% #add filter choice
  filter(filtered != "Dropped") %>% #filter out selected series
  mutate(cpue = case_when( # Calculate CPUE based on data type
    ser_uni_code == "index" ~ das_value,
    ser_uni_code == "nr/m2" ~ das_value,
    ser_uni_code == "kg/ha" ~ das_value,
    ser_uni_code == "nr" & effort == "constant" ~ das_value,
    ser_uni_code == "nr" & effort == "model estimate" ~ das_value,
    ser_uni_code == "kg" & effort == "constant" ~ das_value,
    ser_uni_code == "kg" & effort == "model estimate" ~ das_value,
    TRUE ~ das_value/das_effort
  )
  ) %>% #calculate cpue if effort data is given, otherwise assume that das_value is already CPUE
  select(das_id, das_year, cpue, das_value, das_effort, ser_id, ser_nameshort, ser_hty_code, ser_emu_nameshort, ser_cou_code, ser_distanceseakm, ser_restocking, ecoregion, distance_to_ecoregion, das_qal_id, ser_qal_id)

dbDisconnect(con_wgeel)
```

### Data selection

```{r table_filter, echo = FALSE, tab.cap = "Available silver eel time series. Based on the number of years of available data and the availability of effort data, it is shown whether or not a given series was included in the analysis."}
table <- t.filterchoice %>%
  select(!ser_method) %>% # drop method description
  mutate(notes = ifelse(is.na(notes), "", notes)) %>% #change NAs to blanks in notes
  rename("Series name" = ser_nameshort, #rename table headers
         "Years (n)" = n,
         "Effort data" = effort,
         "Filtered" = filtered,
         "Drop reason" = reason.dropped,
         "Comments" = notes)

knitr::kable(table)
```

```{r figure_series, echo = FALSE, fig.cap = paste("Available CPUE data on provided silver eel time series with at least", min.length, "years of data.", sep = " "), fig.height=length(unique(d.cpue$ser_nameshort))/3*1.5}

ggplot(data = d.cpue, aes(x = das_year, y = cpue)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ser_nameshort, scales = "free", ncol = 3) +
  theme_bw()


```
