---
title: "DATSU eel database"
author: "Cédric Briand"
format:
  html:
    embed-resources: true
editor: visual
---

```{r setup, include=FALSE}



output_format = knitr::opts_knit$get("rmarkdown.pandoc.to")
if (is.null(output_format)){
  table_function <- "kable"
} else {
  table_function <- switch(output_format,
                           "docx" = "flextable",
                           "html" = "kable")
}
nrow_formatted <- function(x){
  if (table_function == "flextable"){
    flextable::nrow_part(x,part="body")
  } else{
    nrow(x)
  }
}


require(knitr)
knitr::opts_chunk$set(echo = FALSE, warnings=FALSE, message=FALSE,error = TRUE) # error TRUE don't stop on error
opts_knit$set(eval.after = 'fig.cap' ) # to be used in chunks used only to plot pictures
options(knitr.table.format = 'pandoc') # options pour kable
options(knitr.kable.NA = '.')
my_pandoc_to <- knitr::opts_knit$get('rmarkdown.pandoc.to') # this variable will tell the kind of compilation used
getUsername <- function(){
	name <- Sys.info()[["user"]]
	return(name)
}
if (getUsername() == "hdrouineau") {
  setwd("~/Documents/Bordeaux/migrateurs/WGEEL/github/wg_WGEEL/R/Rmarkdown/") }
if (getUsername() == "cedric.briand") {
  	knitr::opts_knit$set(root.dir="C:/workspace/wg_WGEEL/R/Rmarkdown")
  setwd("C:/workspace/wg_WGEEL/R/Rmarkdown")
}

```

```{r init}
source("../utilities/load_library.R")

#-----------------
# other libraries

load_package("stringr")
load_package("tidyverse")
load_package("rlang")
load_package("dplyr")
load_package("RColorBrewer")
load_package("scales")
load_package("glue")
library(kableExtra)
load_package("pander")
load_package("ggmap")
load_package("sp")
load_package("yaml")
load_package("RPostgres")
load_package("DBI")


# load functions ------------------------------------------------------------------------------------
# retrieve reference tables needed
# the shiny is launched from shiny_data_integration/shiny thus we need the ../
if(is.null(options()$sqldf.RPostgreSQL.user)) {
	wd <- getwd()
	setwd("../shiny_data_visualisation/shiny_dv")
	source("database_connection.R")
	source("database_reference.R")
	source("database_data.R")
	source("database_precodata.R")
	source("preco_diagram.R")
	source("graphs.R")
	source("maps.R")
	source("filter_and_group_functions.R")
	source("predict_missing.R")
	setwd(wd)
}


load("../shiny_data_visualisation/shiny_dv/data/maps_for_shiny.Rdata") 
# now data are generated by the script load_data_from_the_database.R
load("../shiny_data_visualisation/shiny_dv/data/ref_and_eel_data.Rdata")

cred <- read_yaml("../../credentials.yml")

library(yaml)
host <- cred$host
userwgeel <- cred$user
passwordwgeel <- cred$password

con = dbConnect(RPostgres::Postgres(), 
    dbname=cred$dbname,
    host=cred$host,
    port=cred$port,
    user=cred$user, 
    password=cred$password)
```

During a meeting with Jan-Dag Pohlmann, and Caroline Durif (Chairs), Cédric Briand (busy me) and Maria Makri and Carlos Pintos on the 13 march 2024 we have agreed to exchange with you (start working) to integrate some of the checks done in shiny with DATSU. The first step was to send you some of our data structure so see how to proceed.

Eel data  mostly comprise data stored in the series table or sampling (DCF) data. Those data comprise annual values of abundance, and group and individual metrics. We ignore those for the moment. We start with the main table, containing other type of data are all collected at the level of regional management units (eel management units). These data correspond to landings (all types), restocking, aquaculture. The sql code of the table is show below.

```{sql, echo=TRUE, eval=FALSE}
-- datawg.t_eelstock_eel definition

-- Drop table

-- DROP TABLE datawg.t_eelstock_eel;

CREATE TABLE datawg.t_eelstock_eel (
	eel_id serial4 NOT NULL,
	eel_typ_id int4 NOT NULL,
	eel_year int4 NOT NULL,
	eel_value numeric NULL,
	eel_emu_nameshort varchar(20) NOT NULL,
	eel_cou_code varchar(2) NULL,
	eel_lfs_code varchar(2) NOT NULL,
	eel_hty_code varchar(2) NULL,
	eel_area_division varchar(254) NULL,
	eel_qal_id int4 NOT NULL,
	eel_qal_comment text NULL,
	eel_comment text NULL,
	eel_datelastupdate date NULL,
	eel_missvaluequal varchar(2) NULL,
	eel_datasource varchar(100) NULL,
	eel_dta_code text NULL DEFAULT 'Public'::text,
	CONSTRAINT ck_eel_missvaluequal CHECK ((((eel_missvaluequal)::text = 'NP'::text) OR ((eel_missvaluequal)::text = 'NR'::text) OR ((eel_missvaluequal)::text = 'NC'::text) OR ((eel_missvaluequal)::text = 'ND'::text))),
	CONSTRAINT ck_notnull_value_and_missvalue CHECK ((((eel_missvaluequal IS NULL) AND (eel_value IS NOT NULL)) OR ((eel_missvaluequal IS NOT NULL) AND (eel_value IS NULL)))),
	CONSTRAINT ck_qal_id_and_missvalue CHECK (((eel_missvaluequal IS NULL) OR (eel_qal_id <> 0))),
	CONSTRAINT ck_removed_typid CHECK (((COALESCE(eel_qal_id, 1) > 5) OR (eel_typ_id <> ALL (ARRAY[12, 7, 5])))),
	CONSTRAINT t_eelstock_eel_pkey PRIMARY KEY (eel_id),
	CONSTRAINT c_fk_area_code FOREIGN KEY (eel_area_division) REFERENCES "ref".tr_faoareas(f_division) ON UPDATE CASCADE,
	CONSTRAINT c_fk_cou_code FOREIGN KEY (eel_cou_code) REFERENCES "ref".tr_country_cou(cou_code),
	CONSTRAINT c_fk_eel_dta_code FOREIGN KEY (eel_dta_code) REFERENCES "ref".tr_dataaccess_dta(dta_code) ON UPDATE CASCADE,
	CONSTRAINT c_fk_emu FOREIGN KEY (eel_emu_nameshort,eel_cou_code) REFERENCES "ref".tr_emu_emu(emu_nameshort,emu_cou_code),
	CONSTRAINT c_fk_hty_code FOREIGN KEY (eel_hty_code) REFERENCES "ref".tr_habitattype_hty(hty_code) ON UPDATE CASCADE,
	CONSTRAINT c_fk_lfs_code FOREIGN KEY (eel_lfs_code) REFERENCES "ref".tr_lifestage_lfs(lfs_code) ON UPDATE CASCADE,
	CONSTRAINT c_fk_qal_id FOREIGN KEY (eel_qal_id) REFERENCES "ref".tr_quality_qal(qal_id) ON UPDATE CASCADE,
	CONSTRAINT c_fk_typ_id FOREIGN KEY (eel_typ_id) REFERENCES "ref".tr_typeseries_typ(typ_id) ON UPDATE CASCADE
);
CREATE UNIQUE INDEX idx_eelstock_1 ON datawg.t_eelstock_eel USING btree (eel_year, eel_lfs_code, eel_emu_nameshort, eel_typ_id, eel_hty_code, eel_qal_id, eel_area_division) WHERE ((eel_hty_code IS NOT NULL) AND (eel_area_division IS NOT NULL));
CREATE UNIQUE INDEX idx_eelstock_2 ON datawg.t_eelstock_eel USING btree (eel_year, eel_lfs_code, eel_emu_nameshort, eel_typ_id, eel_qal_id, eel_area_division) WHERE ((eel_hty_code IS NULL) AND (eel_area_division IS NOT NULL));
CREATE UNIQUE INDEX idx_eelstock_3 ON datawg.t_eelstock_eel USING btree (eel_year, eel_lfs_code, eel_emu_nameshort, eel_typ_id, eel_hty_code, eel_qal_id) WHERE ((eel_hty_code IS NOT NULL) AND (eel_area_division IS NULL));
CREATE UNIQUE INDEX idx_eelstock_4 ON datawg.t_eelstock_eel USING btree (eel_year, eel_lfs_code, eel_emu_nameshort, eel_typ_id, eel_qal_id) WHERE ((eel_hty_code IS NULL) AND (eel_area_division IS NULL));

-- Table Triggers

CREATE TRIGGER trg_check_no_ices_area AFTER
INSERT
    OR
UPDATE
    ON
    datawg.t_eelstock_eel FOR EACH ROW EXECUTE FUNCTION check_no_ices_area();
CREATE TRIGGER trg_check_the_stage AFTER
INSERT
    OR
UPDATE
    ON
    datawg.t_eelstock_eel FOR EACH ROW EXECUTE FUNCTION check_the_stage();
CREATE TRIGGER update_eel_time BEFORE
INSERT
    OR
UPDATE
    ON
    datawg.t_eelstock_eel FOR EACH ROW EXECUTE FUNCTION update_eel_last_update();
CREATE TRIGGER trg_check_emu_whole_aquaculture AFTER
INSERT
    OR
UPDATE
    ON
    datawg.t_eelstock_eel FOR EACH ROW EXECUTE FUNCTION checkemu_whole_country();
```

Here is a vision of the content of the table (the last lines entered)

```{r kablelandings}

tail(landings) |> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```
For some reasons, the html doesn't show the image of the table, I'll send it with the email. Still it should show there in the document....

```{r diagrameel, echo=FALSE, include=TRUE,out.width="100%"}

knitr::include_graphics(normalizePath("DATSU/image/t_eelstock_eel_diagram.png"), rel_path = FALSE)
# ![diagram](C:/workspace/wg_WGEEL/R/Rmarkdown/DATSU/image/t_eelstock_eel_diagram.png)
```





The code for the different tables referential tables is the following. I can send you a dump.

## Country

```{r country}
country_ref|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```

## EMU (eel management units)


```{r emu_ref}
emu_ref|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```

## Habitats 

```{r habitat_ref}
habitat_ref|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```

## Life stages

We should complement that with Salmon life stages

```{r lifestages}
DBI::dbGetQuery(con, "select * from ref.tr_lifestage_lfs")|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```


## Marine areas (FAO)

We should complement that with Salmon life stages

```{r tr_faoareas}
DBI::dbGetQuery(con, "select * from ref.tr_faoareas")|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```


## Quality

qal_id means that the data has been removed from actual use in 2018 and kept in the db as historical data

```{r tr_quality_qal}
DBI::dbGetQuery(con, "select * from ref.tr_quality_qal")|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```


## Public status, all should be public, but we keep it here

```{r tr_dataaccess_dta}
DBI::dbGetQuery(con, "select * from ref.tr_dataaccess_dta")|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```

## Data source

```{r tr_datasource_dts}
DBI::dbGetQuery(con, "select * from ref.tr_datasource_dts")|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```


## Type 

```{r tr_type_typ}
DBI::dbGetQuery(con, "select * from ref.tr_typeseries_typ")|> kable("html") |> kable_styling(bootstrap_options =c("striped", "hover", "condensed") )
```